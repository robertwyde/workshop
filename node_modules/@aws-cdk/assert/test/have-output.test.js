"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const fs_1 = require("fs");
const path_1 = require("path");
require("../jest");
let templateFilePath;
let synthStack;
let noOutputStack;
beforeEach(done => {
    synthStack = mkStack({
        Resources: {
            SomeResource: {
                Type: 'Some::Resource',
                Properties: {
                    PropA: 'somevalue'
                }
            },
            AnotherResource: {
                Type: 'Some::AnotherResource',
                Properties: {
                    PropA: 'anothervalue'
                }
            }
        },
        Outputs: {
            TestOutput: {
                Value: {
                    'Fn::GetAtt': [
                        'SomeResource',
                        'Arn'
                    ]
                },
                Export: {
                    Name: 'TestOutputExportName'
                }
            },
            ComplexExportNameOutput: {
                Value: {
                    'Fn::GetAtt': [
                        'ComplexOutputResource',
                        'Arn'
                    ]
                },
                Export: {
                    Name: {
                        "Fn::Sub": "${AWS::StackName}-ComplexExportNameOutput"
                    }
                }
            }
        }
    });
    noOutputStack = mkStack({
        Resources: {
            SomeResource: {
                Type: 'Some::Resource',
                Properties: {
                    PropA: 'somevalue'
                }
            }
        }
    });
    done();
});
test('haveOutput should assert true when output with correct name is provided', () => {
    expect(synthStack).toHaveOutput({
        outputName: 'TestOutput'
    });
});
test('haveOutput should assert false when output with incorrect name is provided', () => {
    expect(synthStack).not.toHaveOutput({
        outputName: 'WrongOutput'
    });
});
test('haveOutput should assert true when output with correct name and export name is provided', () => {
    expect(synthStack).toHaveOutput({
        outputName: 'TestOutput',
        exportName: 'TestOutputExportName',
    });
});
test('haveOutput should assert false when output with correct name and incorrect export name is provided', () => {
    expect(synthStack).not.toHaveOutput({
        outputName: 'TestOutput',
        exportName: 'WrongTestOutputExportName',
    });
});
test('haveOutput should assert true when output with correct name, export name and value is provided', () => {
    expect(synthStack).toHaveOutput({
        outputName: 'TestOutput',
        exportName: 'TestOutputExportName',
        outputValue: {
            'Fn::GetAtt': [
                'SomeResource',
                'Arn'
            ]
        }
    });
});
test('haveOutput should assert false when output with correct name and export name and incorrect value is provided', () => {
    expect(synthStack).not.toHaveOutput({
        outputName: 'TestOutput',
        exportName: 'TestOutputExportName',
        outputValue: 'SomeWrongValue'
    });
});
test('haveOutput should assert true when output with correct export name and value is provided', () => {
    expect(synthStack).toHaveOutput({
        exportName: 'TestOutputExportName',
        outputValue: {
            'Fn::GetAtt': [
                'SomeResource',
                'Arn'
            ]
        }
    });
});
test('haveOutput should assert false when output with correct export name and incorrect value is provided', () => {
    expect(synthStack).not.toHaveOutput({
        exportName: 'TestOutputExportName',
        outputValue: 'WrongValue'
    });
});
test('haveOutput should assert true when output with correct output name and value is provided', () => {
    expect(synthStack).toHaveOutput({
        outputName: 'TestOutput',
        outputValue: {
            'Fn::GetAtt': [
                'SomeResource',
                'Arn'
            ]
        }
    });
});
test('haveOutput should assert false when output with correct output name and incorrect value is provided', () => {
    expect(synthStack).not.toHaveOutput({
        outputName: 'TestOutput',
        outputValue: 'WrongValue'
    });
});
test('haveOutput should assert false when asserting against noOutputStack', () => {
    expect(noOutputStack).not.toHaveOutput({
        outputName: 'TestOutputName',
        exportName: 'TestExportName',
        outputValue: 'TestOutputValue'
    });
});
test('haveOutput should throw Error when none of outputName and exportName is provided', () => {
    expect(() => expect(synthStack).toHaveOutput({ outputValue: 'SomeValue' }))
        .toThrow('At least one of [outputName, exportName] should be provided');
});
test('haveOutput should be able to handle complex exportName values', () => {
    expect(synthStack).toHaveOutput({
        exportName: { 'Fn::Sub': '${AWS::StackName}-ComplexExportNameOutput' },
        outputValue: {
            'Fn::GetAtt': [
                'ComplexOutputResource',
                'Arn'
            ]
        }
    });
});
afterEach(done => {
    if (templateFilePath) {
        fs_1.unlink(templateFilePath, done);
    }
    else {
        done();
    }
});
function mkStack(template) {
    const templateFileName = 'test-have-output-template.json';
    const stackName = 'test-have-output';
    const assembly = new cxapi.CloudAssemblyBuilder();
    assembly.addArtifact(stackName, {
        type: cxapi.ArtifactType.AWS_CLOUDFORMATION_STACK,
        environment: cxapi.EnvironmentUtils.format('123456789012', 'bermuda-triangle-1'),
        properties: {
            templateFile: templateFileName
        }
    });
    templateFilePath = path_1.join(assembly.outdir, templateFileName);
    fs_1.writeFileSync(templateFilePath, JSON.stringify(template));
    return assembly.buildAssembly().getStackByName(stackName);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGF2ZS1vdXRwdXQudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhhdmUtb3V0cHV0LnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx5Q0FBeUM7QUFDekMsMkJBQTJDO0FBQzNDLCtCQUE0QjtBQUM1QixtQkFBaUI7QUFFakIsSUFBSSxnQkFBd0IsQ0FBQztBQUM3QixJQUFJLFVBQTZDLENBQUM7QUFDbEQsSUFBSSxhQUFnRCxDQUFDO0FBRXJELFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRTtJQUNoQixVQUFVLEdBQUcsT0FBTyxDQUFDO1FBQ25CLFNBQVMsRUFBRTtZQUNULFlBQVksRUFBRTtnQkFDWixJQUFJLEVBQUUsZ0JBQWdCO2dCQUN0QixVQUFVLEVBQUU7b0JBQ1YsS0FBSyxFQUFFLFdBQVc7aUJBQ25CO2FBQ0Y7WUFDRCxlQUFlLEVBQUU7Z0JBQ2YsSUFBSSxFQUFFLHVCQUF1QjtnQkFDN0IsVUFBVSxFQUFFO29CQUNWLEtBQUssRUFBRSxjQUFjO2lCQUN0QjthQUNGO1NBQ0Y7UUFDRCxPQUFPLEVBQUU7WUFDUCxVQUFVLEVBQUU7Z0JBQ1YsS0FBSyxFQUFFO29CQUNMLFlBQVksRUFBRTt3QkFDWixjQUFjO3dCQUNkLEtBQUs7cUJBQ047aUJBQ0Y7Z0JBQ0QsTUFBTSxFQUFFO29CQUNOLElBQUksRUFBRSxzQkFBc0I7aUJBQzdCO2FBQ0Y7WUFDRCx1QkFBdUIsRUFBRTtnQkFDdkIsS0FBSyxFQUFFO29CQUNMLFlBQVksRUFBRTt3QkFDWix1QkFBdUI7d0JBQ3ZCLEtBQUs7cUJBQ047aUJBQ0Y7Z0JBQ0QsTUFBTSxFQUFFO29CQUNOLElBQUksRUFBRTt3QkFDSixTQUFTLEVBQUUsMkNBQTJDO3FCQUN2RDtpQkFDRjthQUNGO1NBQ0Y7S0FDRixDQUFDLENBQUM7SUFDSCxhQUFhLEdBQUcsT0FBTyxDQUFDO1FBQ3RCLFNBQVMsRUFBRTtZQUNULFlBQVksRUFBRTtnQkFDWixJQUFJLEVBQUUsZ0JBQWdCO2dCQUN0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QUM7SUFDckMsTUFBTSxRQUFRLEdBQUcsSUFBSSxLQUFLLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztJQUVsRCxRQUFRLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRTtRQUM5QixJQUFJLEVBQUUsS0FBSyxDQUFDLFlBQVksQ0FBQyx3QkFBd0I7UUFDakQsV0FBVyxFQUFFLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLG9CQUFvQixDQUFDO1FBQ2hGLFVBQVUsRUFBRTtZQUNWLFlBQVksRUFBRSxnQkFBZ0I7U0FDL0I7S0FDRixDQUFDLENBQUM7SUFFSCxnQkFBZ0IsR0FBRyxXQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO0lBQzNELGtCQUFhLENBQUMsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBRTFELE9BQU8sUUFBUSxDQUFDLGFBQWEsRUFBRSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUM1RCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB7IHVubGluaywgd3JpdGVGaWxlU3luYyB9IGZyb20gJ2ZzJztcbmltcG9ydCB7IGpvaW4gfSBmcm9tICdwYXRoJztcbmltcG9ydCAnLi4vamVzdCc7XG5cbmxldCB0ZW1wbGF0ZUZpbGVQYXRoOiBzdHJpbmc7XG5sZXQgc3ludGhTdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0O1xubGV0IG5vT3V0cHV0U3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdDtcblxuYmVmb3JlRWFjaChkb25lID0+IHtcbiAgc3ludGhTdGFjayA9IG1rU3RhY2soe1xuICAgIFJlc291cmNlczoge1xuICAgICAgU29tZVJlc291cmNlOiB7XG4gICAgICAgIFR5cGU6ICdTb21lOjpSZXNvdXJjZScsXG4gICAgICAgIFByb3BlcnRpZXM6IHtcbiAgICAgICAgICBQcm9wQTogJ3NvbWV2YWx1ZSdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIEFub3RoZXJSZXNvdXJjZToge1xuICAgICAgICBUeXBlOiAnU29tZTo6QW5vdGhlclJlc291cmNlJyxcbiAgICAgICAgUHJvcGVydGllczoge1xuICAgICAgICAgIFByb3BBOiAnYW5vdGhlcnZhbHVlJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBPdXRwdXRzOiB7XG4gICAgICBUZXN0T3V0cHV0OiB7XG4gICAgICAgIFZhbHVlOiB7XG4gICAgICAgICAgJ0ZuOjpHZXRBdHQnOiBbXG4gICAgICAgICAgICAnU29tZVJlc291cmNlJyxcbiAgICAgICAgICAgICdBcm4nXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBFeHBvcnQ6IHtcbiAgICAgICAgICBOYW1lOiAnVGVzdE91dHB1dEV4cG9ydE5hbWUnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDb21wbGV4RXhwb3J0TmFtZU91dHB1dDoge1xuICAgICAgICBWYWx1ZToge1xuICAgICAgICAgICdGbjo6R2V0QXR0JzogW1xuICAgICAgICAgICAgJ0NvbXBsZXhPdXRwdXRSZXNvdXJjZScsXG4gICAgICAgICAgICAnQXJuJ1xuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgRXhwb3J0OiB7XG4gICAgICAgICAgTmFtZToge1xuICAgICAgICAgICAgXCJGbjo6U3ViXCI6IFwiJHtBV1M6OlN0YWNrTmFtZX0tQ29tcGxleEV4cG9ydE5hbWVPdXRwdXRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIG5vT3V0cHV0U3RhY2sgPSBta1N0YWNrKHtcbiAgICBSZXNvdXJjZXM6IHtcbiAgICAgIFNvbWVSZXNvdXJjZToge1xuICAgICAgICBUeXBlOiAnU29tZTo6UmVzb3VyY2UnLFxuICAgICAgICBQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgUHJvcEE6ICdzb21ldmFsdWUnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBkb25lKCk7XG59KTtcblxudGVzdCgnaGF2ZU91dHB1dCBzaG91bGQgYXNzZXJ0IHRydWUgd2hlbiBvdXRwdXQgd2l0aCBjb3JyZWN0IG5hbWUgaXMgcHJvdmlkZWQnLCAoKSA9PiB7XG4gIGV4cGVjdChzeW50aFN0YWNrKS50b0hhdmVPdXRwdXQoe1xuICAgIG91dHB1dE5hbWU6ICdUZXN0T3V0cHV0J1xuICB9KTtcbn0pO1xuXG50ZXN0KCdoYXZlT3V0cHV0IHNob3VsZCBhc3NlcnQgZmFsc2Ugd2hlbiBvdXRwdXQgd2l0aCBpbmNvcnJlY3QgbmFtZSBpcyBwcm92aWRlZCcsICgpID0+IHtcbiAgZXhwZWN0KHN5bnRoU3RhY2spLm5vdC50b0hhdmVPdXRwdXQoe1xuICAgIG91dHB1dE5hbWU6ICdXcm9uZ091dHB1dCdcbiAgfSk7XG59KTtcblxudGVzdCgnaGF2ZU91dHB1dCBzaG91bGQgYXNzZXJ0IHRydWUgd2hlbiBvdXRwdXQgd2l0aCBjb3JyZWN0IG5hbWUgYW5kIGV4cG9ydCBuYW1lIGlzIHByb3ZpZGVkJywgKCkgPT4ge1xuICBleHBlY3Qoc3ludGhTdGFjaykudG9IYXZlT3V0cHV0KHtcbiAgICBvdXRwdXROYW1lOiAnVGVzdE91dHB1dCcsXG4gICAgZXhwb3J0TmFtZTogJ1Rlc3RPdXRwdXRFeHBvcnROYW1lJyxcbiAgfSk7XG59KTtcblxudGVzdCgnaGF2ZU91dHB1dCBzaG91bGQgYXNzZXJ0IGZhbHNlIHdoZW4gb3V0cHV0IHdpdGggY29ycmVjdCBuYW1lIGFuZCBpbmNvcnJlY3QgZXhwb3J0IG5hbWUgaXMgcHJvdmlkZWQnLCAoKSA9PiB7XG4gIGV4cGVjdChzeW50aFN0YWNrKS5ub3QudG9IYXZlT3V0cHV0KHtcbiAgICBvdXRwdXROYW1lOiAnVGVzdE91dHB1dCcsXG4gICAgZXhwb3J0TmFtZTogJ1dyb25nVGVzdE91dHB1dEV4cG9ydE5hbWUnLFxuICB9KTtcbn0pO1xuXG50ZXN0KCdoYXZlT3V0cHV0IHNob3VsZCBhc3NlcnQgdHJ1ZSB3aGVuIG91dHB1dCB3aXRoIGNvcnJlY3QgbmFtZSwgZXhwb3J0IG5hbWUgYW5kIHZhbHVlIGlzIHByb3ZpZGVkJywgKCkgPT4ge1xuICBleHBlY3Qoc3ludGhTdGFjaykudG9IYXZlT3V0cHV0KHtcbiAgICBvdXRwdXROYW1lOiAnVGVzdE91dHB1dCcsXG4gICAgZXhwb3J0TmFtZTogJ1Rlc3RPdXRwdXRFeHBvcnROYW1lJyxcbiAgICBvdXRwdXRWYWx1ZToge1xuICAgICAgJ0ZuOjpHZXRBdHQnOiBbXG4gICAgICAgICdTb21lUmVzb3VyY2UnLFxuICAgICAgICAnQXJuJ1xuICAgICAgXVxuICAgIH1cbiAgfSk7XG59KTtcblxudGVzdCgnaGF2ZU91dHB1dCBzaG91bGQgYXNzZXJ0IGZhbHNlIHdoZW4gb3V0cHV0IHdpdGggY29ycmVjdCBuYW1lIGFuZCBleHBvcnQgbmFtZSBhbmQgaW5jb3JyZWN0IHZhbHVlIGlzIHByb3ZpZGVkJywgKCkgPT4ge1xuICBleHBlY3Qoc3ludGhTdGFjaykubm90LnRvSGF2ZU91dHB1dCh7XG4gICAgb3V0cHV0TmFtZTogJ1Rlc3RPdXRwdXQnLFxuICAgIGV4cG9ydE5hbWU6ICdUZXN0T3V0cHV0RXhwb3J0TmFtZScsXG4gICAgb3V0cHV0VmFsdWU6ICdTb21lV3JvbmdWYWx1ZSdcbiAgfSk7XG59KTtcblxudGVzdCgnaGF2ZU91dHB1dCBzaG91bGQgYXNzZXJ0IHRydWUgd2hlbiBvdXRwdXQgd2l0aCBjb3JyZWN0IGV4cG9ydCBuYW1lIGFuZCB2YWx1ZSBpcyBwcm92aWRlZCcsICgpID0+IHtcbiAgZXhwZWN0KHN5bnRoU3RhY2spLnRvSGF2ZU91dHB1dCh7XG4gICAgZXhwb3J0TmFtZTogJ1Rlc3RPdXRwdXRFeHBvcnROYW1lJyxcbiAgICBvdXRwdXRWYWx1ZToge1xuICAgICAgJ0ZuOjpHZXRBdHQnOiBbXG4gICAgICAgICdTb21lUmVzb3VyY2UnLFxuICAgICAgICAnQXJuJ1xuICAgICAgXVxuICAgIH1cbiAgfSk7XG59KTtcblxudGVzdCgnaGF2ZU91dHB1dCBzaG91bGQgYXNzZXJ0IGZhbHNlIHdoZW4gb3V0cHV0IHdpdGggY29ycmVjdCBleHBvcnQgbmFtZSBhbmQgaW5jb3JyZWN0IHZhbHVlIGlzIHByb3ZpZGVkJywgKCkgPT4ge1xuICBleHBlY3Qoc3ludGhTdGFjaykubm90LnRvSGF2ZU91dHB1dCh7XG4gICAgZXhwb3J0TmFtZTogJ1Rlc3RPdXRwdXRFeHBvcnROYW1lJyxcbiAgICBvdXRwdXRWYWx1ZTogJ1dyb25nVmFsdWUnXG4gIH0pO1xufSk7XG5cbnRlc3QoJ2hhdmVPdXRwdXQgc2hvdWxkIGFzc2VydCB0cnVlIHdoZW4gb3V0cHV0IHdpdGggY29ycmVjdCBvdXRwdXQgbmFtZSBhbmQgdmFsdWUgaXMgcHJvdmlkZWQnLCAoKSA9PiB7XG4gIGV4cGVjdChzeW50aFN0YWNrKS50b0hhdmVPdXRwdXQoe1xuICAgIG91dHB1dE5hbWU6ICdUZXN0T3V0cHV0JyxcbiAgICBvdXRwdXRWYWx1ZToge1xuICAgICAgJ0ZuOjpHZXRBdHQnOiBbXG4gICAgICAgICdTb21lUmVzb3VyY2UnLFxuICAgICAgICAnQXJuJ1xuICAgICAgXVxuICAgIH1cbiAgfSk7XG59KTtcblxudGVzdCgnaGF2ZU91dHB1dCBzaG91bGQgYXNzZXJ0IGZhbHNlIHdoZW4gb3V0cHV0IHdpdGggY29ycmVjdCBvdXRwdXQgbmFtZSBhbmQgaW5jb3JyZWN0IHZhbHVlIGlzIHByb3ZpZGVkJywgKCkgPT4ge1xuICBleHBlY3Qoc3ludGhTdGFjaykubm90LnRvSGF2ZU91dHB1dCh7XG4gICAgb3V0cHV0TmFtZTogJ1Rlc3RPdXRwdXQnLFxuICAgIG91dHB1dFZhbHVlOiAnV3JvbmdWYWx1ZSdcbiAgfSk7XG59KTtcblxudGVzdCgnaGF2ZU91dHB1dCBzaG91bGQgYXNzZXJ0IGZhbHNlIHdoZW4gYXNzZXJ0aW5nIGFnYWluc3Qgbm9PdXRwdXRTdGFjaycsICgpID0+IHtcbiAgZXhwZWN0KG5vT3V0cHV0U3RhY2spLm5vdC50b0hhdmVPdXRwdXQoe1xuICAgIG91dHB1dE5hbWU6ICdUZXN0T3V0cHV0TmFtZScsXG4gICAgZXhwb3J0TmFtZTogJ1Rlc3RFeHBvcnROYW1lJyxcbiAgICBvdXRwdXRWYWx1ZTogJ1Rlc3RPdXRwdXRWYWx1ZSdcbiAgfSk7XG59KTtcblxudGVzdCgnaGF2ZU91dHB1dCBzaG91bGQgdGhyb3cgRXJyb3Igd2hlbiBub25lIG9mIG91dHB1dE5hbWUgYW5kIGV4cG9ydE5hbWUgaXMgcHJvdmlkZWQnLCAoKSA9PiB7XG4gIGV4cGVjdCgoKSA9PiBleHBlY3Qoc3ludGhTdGFjaykudG9IYXZlT3V0cHV0KHsgb3V0cHV0VmFsdWU6ICdTb21lVmFsdWUnIH0pKVxuICAgIC50b1Rocm93KCdBdCBsZWFzdCBvbmUgb2YgW291dHB1dE5hbWUsIGV4cG9ydE5hbWVdIHNob3VsZCBiZSBwcm92aWRlZCcpO1xufSk7XG5cbnRlc3QoJ2hhdmVPdXRwdXQgc2hvdWxkIGJlIGFibGUgdG8gaGFuZGxlIGNvbXBsZXggZXhwb3J0TmFtZSB2YWx1ZXMnLCAoKSA9PiB7XG4gIGV4cGVjdChzeW50aFN0YWNrKS50b0hhdmVPdXRwdXQoe1xuICAgIGV4cG9ydE5hbWU6IHsnRm46OlN1Yic6ICcke0FXUzo6U3RhY2tOYW1lfS1Db21wbGV4RXhwb3J0TmFtZU91dHB1dCd9LFxuICAgIG91dHB1dFZhbHVlOiB7XG4gICAgICAnRm46OkdldEF0dCc6IFtcbiAgICAgICAgJ0NvbXBsZXhPdXRwdXRSZXNvdXJjZScsXG4gICAgICAgICdBcm4nXG4gICAgICBdXG4gICAgfVxuICB9KTtcbn0pO1xuXG5hZnRlckVhY2goZG9uZSA9PiB7XG4gIGlmICh0ZW1wbGF0ZUZpbGVQYXRoKSB7XG4gICAgdW5saW5rKHRlbXBsYXRlRmlsZVBhdGgsIGRvbmUpO1xuICB9IGVsc2Uge1xuICAgIGRvbmUoKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIG1rU3RhY2sodGVtcGxhdGU6IGFueSk6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCB7XG4gIGNvbnN0IHRlbXBsYXRlRmlsZU5hbWUgPSAndGVzdC1oYXZlLW91dHB1dC10ZW1wbGF0ZS5qc29uJztcbiAgY29uc3Qgc3RhY2tOYW1lID0gJ3Rlc3QtaGF2ZS1vdXRwdXQnO1xuICBjb25zdCBhc3NlbWJseSA9IG5ldyBjeGFwaS5DbG91ZEFzc2VtYmx5QnVpbGRlcigpO1xuXG4gIGFzc2VtYmx5LmFkZEFydGlmYWN0KHN0YWNrTmFtZSwge1xuICAgIHR5cGU6IGN4YXBpLkFydGlmYWN0VHlwZS5BV1NfQ0xPVURGT1JNQVRJT05fU1RBQ0ssXG4gICAgZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50VXRpbHMuZm9ybWF0KCcxMjM0NTY3ODkwMTInLCAnYmVybXVkYS10cmlhbmdsZS0xJyksXG4gICAgcHJvcGVydGllczoge1xuICAgICAgdGVtcGxhdGVGaWxlOiB0ZW1wbGF0ZUZpbGVOYW1lXG4gICAgfVxuICB9KTtcblxuICB0ZW1wbGF0ZUZpbGVQYXRoID0gam9pbihhc3NlbWJseS5vdXRkaXIsIHRlbXBsYXRlRmlsZU5hbWUpO1xuICB3cml0ZUZpbGVTeW5jKHRlbXBsYXRlRmlsZVBhdGgsIEpTT04uc3RyaW5naWZ5KHRlbXBsYXRlKSk7XG5cbiAgcmV0dXJuIGFzc2VtYmx5LmJ1aWxkQXNzZW1ibHkoKS5nZXRTdGFja0J5TmFtZShzdGFja05hbWUpO1xufVxuIl19