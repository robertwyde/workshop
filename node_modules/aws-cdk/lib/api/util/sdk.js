"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const AWS = require("aws-sdk");
const child_process = require("child_process");
const fs = require("fs-extra");
const https = require("https");
const os = require("os");
const path = require("path");
const util = require("util");
const logging_1 = require("../../logging");
const plugin_1 = require("../../plugin");
const account_cache_1 = require("./account-cache");
const sdk_ini_file_1 = require("./sdk_ini_file");
/**
 * Source for SDK client objects
 *
 * Credentials are first obtained from the SDK defaults (using environment variables and the
 * ~/.aws/{config,credentials} files).
 *
 * If those don't suffice, a list of CredentialProviderSources is interrogated for access
 * to the requested account.
 *
 * @experimental
 */
class SDK {
    constructor(options = {}) {
        /**
         * Default retry options for SDK clients
         *
         * Biggest bottleneck is CloudFormation, with a 1tps call rate. We want to be
         * a little more tenacious than the defaults, and with a little more breathing
         * room between calls (defaults are {retries=3, base=100}).
         *
         * I've left this running in a tight loop for an hour and the throttle errors
         * haven't escaped the retry mechanism.
         */
        this.retryOptions = { maxRetries: 6, retryDelayOptions: { base: 300 } };
        this.profile = options.profile;
        const defaultCredentialProvider = makeCLICompatibleCredentialProvider(options.profile, options.ec2creds);
        this.configureSDKHttpOptions(options);
        this.defaultAwsAccount = new DefaultAWSAccount(defaultCredentialProvider, getCLICompatibleDefaultRegionGetter(this.profile));
        this.credentialsCache = new CredentialsCache(this.defaultAwsAccount, defaultCredentialProvider);
    }
    async cloudFormation(account, region, mode) {
        const environment = await this.resolveEnvironment(account, region);
        return new AWS.CloudFormation({
            ...this.retryOptions,
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode)
        });
    }
    async ec2(account, region, mode) {
        const environment = await this.resolveEnvironment(account, region);
        return new AWS.EC2({
            ...this.retryOptions,
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode)
        });
    }
    async ssm(account, region, mode) {
        const environment = await this.resolveEnvironment(account, region);
        return new AWS.SSM({
            ...this.retryOptions,
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode)
        });
    }
    async s3(account, region, mode) {
        const environment = await this.resolveEnvironment(account, region);
        return new AWS.S3({
            ...this.retryOptions,
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode)
        });
    }
    async route53(account, region, mode) {
        const environment = await this.resolveEnvironment(account, region);
        return new AWS.Route53({
            ...this.retryOptions,
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode),
        });
    }
    async ecr(account, region, mode) {
        const environment = await this.resolveEnvironment(account, region);
        return new AWS.ECR({
            ...this.retryOptions,
            region: environment.region,
            credentials: await this.credentialsCache.get(environment.account, mode)
        });
    }
    async defaultRegion() {
        return await getCLICompatibleDefaultRegionGetter(this.profile)();
    }
    defaultAccount() {
        return this.defaultAwsAccount.get();
    }
    async resolveEnvironment(account, region) {
        if (region === cxapi.UNKNOWN_REGION) {
            region = await this.defaultRegion();
        }
        if (account === cxapi.UNKNOWN_ACCOUNT) {
            account = await this.defaultAccount();
        }
        if (!region) {
            throw new Error(`AWS region must be configured either when you configure your CDK stack or through the environment`);
        }
        if (!account) {
            throw new Error(`Unable to resolve AWS account to use. It must be either configured when you define your CDK or through the environment`);
        }
        const environment = {
            region, account, name: cxapi.EnvironmentUtils.format(account, region)
        };
        return environment;
    }
    configureSDKHttpOptions(options) {
        const config = {};
        config.httpOptions = {};
        let userAgent = options.userAgent;
        if (userAgent == null) {
            // Find the package.json from the main toolkit
            const pkg = require.main.require('../package.json');
            userAgent = `${pkg.name}/${pkg.version}`;
        }
        config.customUserAgent = userAgent;
        const proxyAddress = options.proxyAddress || httpsProxyFromEnvironment();
        const caBundlePath = options.caBundlePath || caBundlePathFromEnvironment();
        if (proxyAddress && caBundlePath) {
            throw new Error(`At the moment, cannot specify Proxy (${proxyAddress}) and CA Bundle (${caBundlePath}) at the same time. See https://github.com/aws/aws-cdk/issues/5804`);
            // Maybe it's possible after all, but I've been staring at
            // https://github.com/TooTallNate/node-proxy-agent/blob/master/index.js#L79
            // a while now trying to figure out what to pass in so that the underlying Agent
            // object will get the 'ca' argument. It's not trivial and I don't want to risk it.
        }
        if (proxyAddress) { // Ignore empty string on purpose
            // https://aws.amazon.com/blogs/developer/using-the-aws-sdk-for-javascript-from-behind-a-proxy/
            logging_1.debug('Using proxy server: %s', proxyAddress);
            // eslint-disable-next-line @typescript-eslint/no-require-imports
            const ProxyAgent = require('proxy-agent');
            config.httpOptions.agent = new ProxyAgent(proxyAddress);
        }
        if (caBundlePath) {
            logging_1.debug('Using CA bundle path: %s', caBundlePath);
            config.httpOptions.agent = new https.Agent({
                ca: readIfPossible(caBundlePath)
            });
        }
        AWS.config.update(config);
    }
}
exports.SDK = SDK;
/**
 * Cache for credential providers.
 *
 * Given an account and an operating mode (read or write) will return an
 * appropriate credential provider for credentials for the given account. The
 * credential provider will be cached so that multiple AWS clients for the same
 * environment will not make multiple network calls to obtain credentials.
 *
 * Will use default credentials if they are for the right account; otherwise,
 * all loaded credential provider plugins will be tried to obtain credentials
 * for the given account.
 */
class CredentialsCache {
    constructor(defaultAwsAccount, defaultCredentialProvider) {
        this.defaultAwsAccount = defaultAwsAccount;
        this.defaultCredentialProvider = defaultCredentialProvider;
        this.cache = {};
    }
    async get(awsAccountId, mode) {
        const key = `${awsAccountId}-${mode}`;
        if (!(key in this.cache)) {
            this.cache[key] = await this.getCredentials(awsAccountId, mode);
        }
        return this.cache[key];
    }
    async getCredentials(awsAccountId, mode) {
        // If requested account is undefined or equal to default account, use default credentials provider.
        // (Note that we ignore the mode in this case, if you preloaded credentials they better be correct!)
        const defaultAccount = await this.defaultAwsAccount.get();
        if (!awsAccountId || awsAccountId === defaultAccount || awsAccountId === cxapi.UNKNOWN_ACCOUNT) {
            logging_1.debug(`Using default AWS SDK credentials for account ${awsAccountId}`);
            // CredentialProviderChain extends Credentials, but that is a lie.
            // https://github.com/aws/aws-sdk-js/issues/2235
            // Call resolve() instead.
            return (await this.defaultCredentialProvider).resolvePromise();
        }
        const triedSources = [];
        // Otherwise, inspect the various credential sources we have
        for (const source of plugin_1.PluginHost.instance.credentialProviderSources) {
            if (!(await source.isAvailable())) {
                logging_1.debug('Credentials source %s is not available, ignoring it.', source.name);
                continue;
            }
            triedSources.push(source);
            if (!(await source.canProvideCredentials(awsAccountId))) {
                continue;
            }
            logging_1.debug(`Using ${source.name} credentials for account ${awsAccountId}`);
            const providerOrCreds = await source.getProvider(awsAccountId, mode);
            // Backwards compatibility: if the plugin returns a ProviderChain, resolve that chain.
            // Otherwise it must have returned credentials.
            if (providerOrCreds.resolvePromise) {
                return await providerOrCreds.resolvePromise();
            }
            return providerOrCreds;
        }
        const sourceNames = ['default credentials'].concat(triedSources.map(s => s.name)).join(', ');
        throw new Error(`Need to perform AWS calls for account ${awsAccountId}, but no credentials found. Tried: ${sourceNames}.`);
    }
}
/**
 * Class to retrieve the account for default credentials and cache it.
 *
 * Uses the default credentials provider to obtain credentials (if available),
 * and uses those credentials to call STS to request the current account ID.
 *
 * The credentials => accountId lookup is cached on disk, since it's
 * guaranteed that igven access key will always remain for the same account.
 */
class DefaultAWSAccount {
    constructor(defaultCredentialsProvider, region) {
        this.defaultCredentialsProvider = defaultCredentialsProvider;
        this.region = region;
        this.defaultAccountFetched = false;
        this.defaultAccountId = undefined;
        this.accountCache = new account_cache_1.AccountAccessKeyCache();
    }
    /**
     * Return the default account
     */
    async get() {
        if (!this.defaultAccountFetched) {
            this.defaultAccountId = await this.lookupDefaultAccount();
            this.defaultAccountFetched = true;
        }
        return this.defaultAccountId;
    }
    async lookupDefaultAccount() {
        try {
            // There just is *NO* way to do AssumeRole credentials as long as AWS_SDK_LOAD_CONFIG is not set. The SDK
            // crash if the file does not exist though. So set the environment variable if we can find that file.
            await setConfigVariable();
            logging_1.debug('Resolving default credentials');
            const credentialProvider = await this.defaultCredentialsProvider;
            const creds = await credentialProvider.resolvePromise();
            const accessKeyId = creds.accessKeyId;
            if (!accessKeyId) {
                throw new Error('Unable to resolve AWS credentials (setup with "aws configure")');
            }
            const accountId = await this.accountCache.fetch(creds.accessKeyId, async () => {
                // if we don't have one, resolve from STS and store in cache.
                logging_1.debug('Looking up default account ID from STS');
                const result = await new AWS.STS({ credentials: creds, region: await this.region() }).getCallerIdentity().promise();
                const aid = result.Account;
                if (!aid) {
                    logging_1.debug('STS didn\'t return an account ID');
                    return undefined;
                }
                logging_1.debug('Default account ID:', aid);
                return aid;
            });
            return accountId;
        }
        catch (e) {
            logging_1.debug('Unable to determine the default AWS account (did you configure "aws configure"?):', e);
            return undefined;
        }
    }
}
/**
 * Build an AWS CLI-compatible credential chain provider
 *
 * This is similar to the default credential provider chain created by the SDK
 * except it also accepts the profile argument in the constructor (not just from
 * the environment).
 *
 * To mimic the AWS CLI behavior:
 *
 * - we default to ~/.aws/credentials if environment variable for credentials
 * file location is not given (SDK expects explicit environment variable with name).
 * - AWS_DEFAULT_PROFILE is also inspected for profile name (not just AWS_PROFILE).
 */
async function makeCLICompatibleCredentialProvider(profile, ec2creds) {
    profile = profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
    // Need to construct filename ourselves, without appropriate environment variables
    // no defaults used by JS SDK.
    const filename = process.env.AWS_SHARED_CREDENTIALS_FILE || path.join(os.homedir(), '.aws', 'credentials');
    const sources = [
        () => new AWS.EnvironmentCredentials('AWS'),
        () => new AWS.EnvironmentCredentials('AMAZON'),
    ];
    if (fs.pathExists(filename)) {
        sources.push(() => new AWS.SharedIniFileCredentials({ profile, filename }));
    }
    if (hasEcsCredentials()) {
        sources.push(() => new AWS.ECSCredentials());
    }
    else {
        // else if: don't get EC2 creds if we should have gotten ECS creds--ECS instances also
        // run on EC2 boxes but the creds represent something different. Same behavior as
        // upstream code.
        if (ec2creds === undefined) {
            ec2creds = await hasEc2Credentials();
        }
        if (ec2creds) {
            sources.push(() => new AWS.EC2MetadataCredentials());
        }
    }
    return new AWS.CredentialProviderChain(sources);
}
/**
 * Return the default region in a CLI-compatible way
 *
 * Mostly copied from node_loader.js, but with the following differences:
 *
 * - Takes a runtime profile name to load the region from, not just based on environment
 *   variables at process start.
 * - We have needed to create a local copy of the SharedIniFile class because the
 *   implementation in 'aws-sdk' is private (and the default use of it in the
 *   SDK does not allow us to specify a profile at runtime).
 * - AWS_DEFAULT_PROFILE and AWS_DEFAULT_REGION are also used as environment
 *   variables to be used to determine the region.
 *
 * Returns a function that can be invoked to retrieve the actual region value
 * (used to be just a promise, but that would lead to firing off a failing
 * operation and if it was never awaited NodeJS would complain).
 */
function getCLICompatibleDefaultRegionGetter(profile) {
    let retrieved = false;
    let region;
    return async () => {
        if (!retrieved) {
            profile = profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
            // Defaults inside constructor
            const toCheck = [
                { filename: process.env.AWS_SHARED_CREDENTIALS_FILE },
                { isConfig: true, filename: process.env.AWS_CONFIG_FILE },
            ];
            region = process.env.AWS_REGION || process.env.AMAZON_REGION ||
                process.env.AWS_DEFAULT_REGION || process.env.AMAZON_DEFAULT_REGION;
            while (!region && toCheck.length > 0) {
                const configFile = new sdk_ini_file_1.SharedIniFile(toCheck.shift());
                const section = await configFile.getProfile(profile);
                region = section && section.region;
            }
            if (!region) {
                const usedProfile = !profile ? '' : ` (profile: "${profile}")`;
                logging_1.debug(`Unable to determine AWS region from environment or AWS configuration${usedProfile}`);
            }
            retrieved = true;
        }
        return region;
    };
}
/**
 * Find and return the configured HTTPS proxy address
 */
function httpsProxyFromEnvironment() {
    if (process.env.https_proxy) {
        return process.env.https_proxy;
    }
    if (process.env.HTTPS_PROXY) {
        return process.env.HTTPS_PROXY;
    }
    return undefined;
}
/**
 * Find and return a CA certificate bundle path to be passed into the SDK.
 */
function caBundlePathFromEnvironment() {
    if (process.env.aws_ca_bundle) {
        return process.env.aws_ca_bundle;
    }
    if (process.env.AWS_CA_BUNDLE) {
        return process.env.AWS_CA_BUNDLE;
    }
    return undefined;
}
/**
 * Return whether it looks like we'll have ECS credentials available
 */
function hasEcsCredentials() {
    return AWS.ECSCredentials.prototype.isConfiguredForEcsCredentials();
}
/**
 * Return whether we're on an EC2 instance
 */
async function hasEc2Credentials() {
    logging_1.debug("Determining whether we're on an EC2 instance.");
    let instance = false;
    if (process.platform === 'win32') {
        // https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/identify_ec2_instances.html
        const result = await util.promisify(child_process.exec)('wmic path win32_computersystemproduct get uuid', { encoding: 'utf-8' });
        // output looks like
        //  UUID
        //  EC2AE145-D1DC-13B2-94ED-01234ABCDEF
        const lines = result.stdout.toString().split('\n');
        instance = lines.some(x => matchesRegex(/^ec2/i, x));
    }
    else {
        // https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/identify_ec2_instances.html
        const files = [
            // This recognizes the Xen hypervisor based instances (pre-5th gen)
            ['/sys/hypervisor/uuid', /^ec2/i],
            // This recognizes the new Hypervisor (5th-gen instances and higher)
            // Can't use the advertised file '/sys/devices/virtual/dmi/id/product_uuid' because it requires root to read.
            // Instead, sys_vendor contains something like 'Amazon EC2'.
            ['/sys/devices/virtual/dmi/id/sys_vendor', /ec2/i],
        ];
        for (const [file, re] of files) {
            if (matchesRegex(re, readIfPossible(file))) {
                instance = true;
                break;
            }
        }
    }
    logging_1.debug(instance ? 'Looks like EC2 instance.' : 'Does not look like EC2 instance.');
    return instance;
}
async function setConfigVariable() {
    const homeDir = process.env.HOME || process.env.USERPROFILE
        || (process.env.HOMEPATH ? ((process.env.HOMEDRIVE || 'C:/') + process.env.HOMEPATH) : null) || os.homedir();
    if (await fs.pathExists(path.resolve(homeDir, '.aws', 'config'))) {
        process.env.AWS_SDK_LOAD_CONFIG = '1';
    }
}
/**
 * Read a file if it exists, or return undefined
 *
 * Not async because it is used in the constructor
 */
function readIfPossible(filename) {
    try {
        if (!fs.pathExistsSync(filename)) {
            return undefined;
        }
        return fs.readFileSync(filename, { encoding: 'utf-8' });
    }
    catch (e) {
        logging_1.debug(e);
        return undefined;
    }
}
function matchesRegex(re, s) {
    return s !== undefined && re.exec(s) !== null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2RrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2RrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEseUNBQXlDO0FBQ3pDLCtCQUErQjtBQUMvQiwrQ0FBK0M7QUFDL0MsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQix5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QiwyQ0FBc0M7QUFDdEMseUNBQTBDO0FBRTFDLG1EQUF3RDtBQUN4RCxpREFBK0M7QUE0RC9DOzs7Ozs7Ozs7O0dBVUc7QUFDSCxNQUFhLEdBQUc7SUFpQmQsWUFBWSxVQUFzQixFQUFFO1FBWnBDOzs7Ozs7Ozs7V0FTRztRQUNjLGlCQUFZLEdBQUcsRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLGlCQUFpQixFQUFFLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxFQUFDLENBQUM7UUFHakYsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDO1FBRS9CLE1BQU0seUJBQXlCLEdBQUcsbUNBQW1DLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFekcsSUFBSSxDQUFDLHVCQUF1QixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXRDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLGlCQUFpQixDQUFDLHlCQUF5QixFQUFFLG1DQUFtQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQzdILElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLGdCQUFnQixDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSx5QkFBeUIsQ0FBQyxDQUFDO0lBQ2xHLENBQUM7SUFFTSxLQUFLLENBQUMsY0FBYyxDQUFDLE9BQTJCLEVBQUUsTUFBMEIsRUFBRSxJQUFVO1FBQzdGLE1BQU0sV0FBVyxHQUFHLE1BQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQztR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QUFFLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQUUsT0FBTyxTQUFTLENBQUM7U0FBRTtRQUN2RCxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7S0FDekQ7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLGVBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNULE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0FBQ0gsQ0FBQztBQUVELFNBQVMsWUFBWSxDQUFDLEVBQVUsRUFBRSxDQUFxQjtJQUNyRCxPQUFPLENBQUMsS0FBSyxTQUFTLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUM7QUFDaEQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBBV1MgZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgKiBhcyBjaGlsZF9wcm9jZXNzIGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgaHR0cHMgZnJvbSAnaHR0cHMnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAndXRpbCc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgUGx1Z2luSG9zdCB9IGZyb20gJy4uLy4uL3BsdWdpbic7XG5pbXBvcnQgeyBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2UsIE1vZGUgfSBmcm9tICcuLi9hd3MtYXV0aC9jcmVkZW50aWFscyc7XG5pbXBvcnQgeyBBY2NvdW50QWNjZXNzS2V5Q2FjaGUgfSBmcm9tICcuL2FjY291bnQtY2FjaGUnO1xuaW1wb3J0IHsgU2hhcmVkSW5pRmlsZSB9IGZyb20gJy4vc2RrX2luaV9maWxlJztcblxuLyoqIEBleHBlcmltZW50YWwgKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVNESyB7XG4gIGNsb3VkRm9ybWF0aW9uKGFjY291bnQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgcmVnaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPEFXUy5DbG91ZEZvcm1hdGlvbj47XG5cbiAgZWMyKGFjY291bnQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgcmVnaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPEFXUy5FQzI+O1xuXG4gIHNzbShhY2NvdW50OiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuU1NNPjtcblxuICBzMyhhY2NvdW50OiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuUzM+O1xuXG4gIHJvdXRlNTMoYWNjb3VudDogc3RyaW5nIHwgdW5kZWZpbmVkLCByZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLlJvdXRlNTM+O1xuXG4gIGVjcihhY2NvdW50OiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuRUNSPjtcblxuICBkZWZhdWx0UmVnaW9uKCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPjtcblxuICBkZWZhdWx0QWNjb3VudCgpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU0RLT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBQcm9maWxlIG5hbWUgdG8gdXNlXG4gICAqXG4gICAqIEBkZWZhdWx0IE5vIHByb2ZpbGVcbiAgICovXG4gIHByb2ZpbGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFByb3h5IGFkZHJlc3MgdG8gdXNlXG4gICAqXG4gICAqIEBkZWZhdWx0IE5vIHByb3h5XG4gICAqL1xuICBwcm94eUFkZHJlc3M/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgd2Ugc2hvdWxkIHRyeSBpbnN0YW5jZSBjcmVkZW50aWFsc1xuICAgKlxuICAgKiBUcnVlL2ZhbHNlIHRvIGZvcmNlL2Rpc2FibGUuIERlZmF1bHQgaXMgdG8gZ3Vlc3MuXG4gICAqXG4gICAqIEBkZWZhdWx0IEF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lLlxuICAgKi9cbiAgZWMyY3JlZHM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBIHBhdGggdG8gYSBjZXJ0aWZpY2F0ZSBidW5kbGUgdGhhdCBjb250YWlucyBhIGNlcnQgdG8gYmUgdHJ1c3RlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgTm8gY2VydGlmaWNhdGUgYnVuZGxlXG4gICAqL1xuICBjYUJ1bmRsZVBhdGg/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBjdXN0b20gc3VlciBhZ2VudCB0byB1c2UuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gPHBhY2thZ2UtbmFtZT4vPHBhY2thZ2UtdmVyc2lvbj5cbiAgICovXG4gIHVzZXJBZ2VudD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBTb3VyY2UgZm9yIFNESyBjbGllbnQgb2JqZWN0c1xuICpcbiAqIENyZWRlbnRpYWxzIGFyZSBmaXJzdCBvYnRhaW5lZCBmcm9tIHRoZSBTREsgZGVmYXVsdHMgKHVzaW5nIGVudmlyb25tZW50IHZhcmlhYmxlcyBhbmQgdGhlXG4gKiB+Ly5hd3Mve2NvbmZpZyxjcmVkZW50aWFsc30gZmlsZXMpLlxuICpcbiAqIElmIHRob3NlIGRvbid0IHN1ZmZpY2UsIGEgbGlzdCBvZiBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2VzIGlzIGludGVycm9nYXRlZCBmb3IgYWNjZXNzXG4gKiB0byB0aGUgcmVxdWVzdGVkIGFjY291bnQuXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgY2xhc3MgU0RLIGltcGxlbWVudHMgSVNESyB7XG4gIHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdEF3c0FjY291bnQ6IERlZmF1bHRBV1NBY2NvdW50O1xuICBwcml2YXRlIHJlYWRvbmx5IGNyZWRlbnRpYWxzQ2FjaGU6IENyZWRlbnRpYWxzQ2FjaGU7XG4gIHByaXZhdGUgcmVhZG9ubHkgcHJvZmlsZT86IHN0cmluZztcblxuICAvKipcbiAgICogRGVmYXVsdCByZXRyeSBvcHRpb25zIGZvciBTREsgY2xpZW50c1xuICAgKlxuICAgKiBCaWdnZXN0IGJvdHRsZW5lY2sgaXMgQ2xvdWRGb3JtYXRpb24sIHdpdGggYSAxdHBzIGNhbGwgcmF0ZS4gV2Ugd2FudCB0byBiZVxuICAgKiBhIGxpdHRsZSBtb3JlIHRlbmFjaW91cyB0aGFuIHRoZSBkZWZhdWx0cywgYW5kIHdpdGggYSBsaXR0bGUgbW9yZSBicmVhdGhpbmdcbiAgICogcm9vbSBiZXR3ZWVuIGNhbGxzIChkZWZhdWx0cyBhcmUge3JldHJpZXM9MywgYmFzZT0xMDB9KS5cbiAgICpcbiAgICogSSd2ZSBsZWZ0IHRoaXMgcnVubmluZyBpbiBhIHRpZ2h0IGxvb3AgZm9yIGFuIGhvdXIgYW5kIHRoZSB0aHJvdHRsZSBlcnJvcnNcbiAgICogaGF2ZW4ndCBlc2NhcGVkIHRoZSByZXRyeSBtZWNoYW5pc20uXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHJldHJ5T3B0aW9ucyA9IHsgbWF4UmV0cmllczogNiwgcmV0cnlEZWxheU9wdGlvbnM6IHsgYmFzZTogMzAwIH19O1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFNES09wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMucHJvZmlsZSA9IG9wdGlvbnMucHJvZmlsZTtcblxuICAgIGNvbnN0IGRlZmF1bHRDcmVkZW50aWFsUHJvdmlkZXIgPSBtYWtlQ0xJQ29tcGF0aWJsZUNyZWRlbnRpYWxQcm92aWRlcihvcHRpb25zLnByb2ZpbGUsIG9wdGlvbnMuZWMyY3JlZHMpO1xuXG4gICAgdGhpcy5jb25maWd1cmVTREtIdHRwT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIHRoaXMuZGVmYXVsdEF3c0FjY291bnQgPSBuZXcgRGVmYXVsdEFXU0FjY291bnQoZGVmYXVsdENyZWRlbnRpYWxQcm92aWRlciwgZ2V0Q0xJQ29tcGF0aWJsZURlZmF1bHRSZWdpb25HZXR0ZXIodGhpcy5wcm9maWxlKSk7XG4gICAgdGhpcy5jcmVkZW50aWFsc0NhY2hlID0gbmV3IENyZWRlbnRpYWxzQ2FjaGUodGhpcy5kZWZhdWx0QXdzQWNjb3VudCwgZGVmYXVsdENyZWRlbnRpYWxQcm92aWRlcik7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xvdWRGb3JtYXRpb24oYWNjb3VudDogc3RyaW5nIHwgdW5kZWZpbmVkLCByZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLkNsb3VkRm9ybWF0aW9uPiB7XG4gICAgY29uc3QgZW52aXJvbm1lbnQgPSBhd2FpdCB0aGlzLnJlc29sdmVFbnZpcm9ubWVudChhY2NvdW50LCByZWdpb24pO1xuICAgIHJldHVybiBuZXcgQVdTLkNsb3VkRm9ybWF0aW9uKHtcbiAgICAgIC4uLnRoaXMucmV0cnlPcHRpb25zLFxuICAgICAgcmVnaW9uOiBlbnZpcm9ubWVudC5yZWdpb24sXG4gICAgICBjcmVkZW50aWFsczogYXdhaXQgdGhpcy5jcmVkZW50aWFsc0NhY2hlLmdldChlbnZpcm9ubWVudC5hY2NvdW50LCBtb2RlKVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGVjMihhY2NvdW50OiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuRUMyPiB7XG4gICAgY29uc3QgZW52aXJvbm1lbnQgPSBhd2FpdCB0aGlzLnJlc29sdmVFbnZpcm9ubWVudChhY2NvdW50LCByZWdpb24pO1xuICAgIHJldHVybiBuZXcgQVdTLkVDMih7XG4gICAgICAuLi50aGlzLnJldHJ5T3B0aW9ucyxcbiAgICAgIHJlZ2lvbjogZW52aXJvbm1lbnQucmVnaW9uLFxuICAgICAgY3JlZGVudGlhbHM6IGF3YWl0IHRoaXMuY3JlZGVudGlhbHNDYWNoZS5nZXQoZW52aXJvbm1lbnQuYWNjb3VudCwgbW9kZSlcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzc20oYWNjb3VudDogc3RyaW5nIHwgdW5kZWZpbmVkLCByZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLlNTTT4ge1xuICAgIGNvbnN0IGVudmlyb25tZW50ID0gYXdhaXQgdGhpcy5yZXNvbHZlRW52aXJvbm1lbnQoYWNjb3VudCwgcmVnaW9uKTtcbiAgICByZXR1cm4gbmV3IEFXUy5TU00oe1xuICAgICAgLi4udGhpcy5yZXRyeU9wdGlvbnMsXG4gICAgICByZWdpb246IGVudmlyb25tZW50LnJlZ2lvbixcbiAgICAgIGNyZWRlbnRpYWxzOiBhd2FpdCB0aGlzLmNyZWRlbnRpYWxzQ2FjaGUuZ2V0KGVudmlyb25tZW50LmFjY291bnQsIG1vZGUpXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgczMoYWNjb3VudDogc3RyaW5nIHwgdW5kZWZpbmVkLCByZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLlMzPiB7XG4gICAgY29uc3QgZW52aXJvbm1lbnQgPSBhd2FpdCB0aGlzLnJlc29sdmVFbnZpcm9ubWVudChhY2NvdW50LCByZWdpb24pO1xuICAgIHJldHVybiBuZXcgQVdTLlMzKHtcbiAgICAgIC4uLnRoaXMucmV0cnlPcHRpb25zLFxuICAgICAgcmVnaW9uOiBlbnZpcm9ubWVudC5yZWdpb24sXG4gICAgICBjcmVkZW50aWFsczogYXdhaXQgdGhpcy5jcmVkZW50aWFsc0NhY2hlLmdldChlbnZpcm9ubWVudC5hY2NvdW50LCBtb2RlKVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJvdXRlNTMoYWNjb3VudDogc3RyaW5nIHwgdW5kZWZpbmVkLCByZWdpb246IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLlJvdXRlNTM+IHtcbiAgICBjb25zdCBlbnZpcm9ubWVudCA9IGF3YWl0IHRoaXMucmVzb2x2ZUVudmlyb25tZW50KGFjY291bnQsIHJlZ2lvbik7XG4gICAgcmV0dXJuIG5ldyBBV1MuUm91dGU1Myh7XG4gICAgICAuLi50aGlzLnJldHJ5T3B0aW9ucyxcbiAgICAgIHJlZ2lvbjogZW52aXJvbm1lbnQucmVnaW9uLFxuICAgICAgY3JlZGVudGlhbHM6IGF3YWl0IHRoaXMuY3JlZGVudGlhbHNDYWNoZS5nZXQoZW52aXJvbm1lbnQuYWNjb3VudCwgbW9kZSksXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZWNyKGFjY291bnQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgcmVnaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPEFXUy5FQ1I+IHtcbiAgICBjb25zdCBlbnZpcm9ubWVudCA9IGF3YWl0IHRoaXMucmVzb2x2ZUVudmlyb25tZW50KGFjY291bnQsIHJlZ2lvbik7XG4gICAgcmV0dXJuIG5ldyBBV1MuRUNSKHtcbiAgICAgIC4uLnRoaXMucmV0cnlPcHRpb25zLFxuICAgICAgcmVnaW9uOiBlbnZpcm9ubWVudC5yZWdpb24sXG4gICAgICBjcmVkZW50aWFsczogYXdhaXQgdGhpcy5jcmVkZW50aWFsc0NhY2hlLmdldChlbnZpcm9ubWVudC5hY2NvdW50LCBtb2RlKVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlZmF1bHRSZWdpb24oKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gYXdhaXQgZ2V0Q0xJQ29tcGF0aWJsZURlZmF1bHRSZWdpb25HZXR0ZXIodGhpcy5wcm9maWxlKSgpO1xuICB9XG5cbiAgcHVibGljIGRlZmF1bHRBY2NvdW50KCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdEF3c0FjY291bnQuZ2V0KCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJlc29sdmVFbnZpcm9ubWVudChhY2NvdW50OiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLCApIHtcbiAgICBpZiAocmVnaW9uID09PSBjeGFwaS5VTktOT1dOX1JFR0lPTikge1xuICAgICAgcmVnaW9uID0gYXdhaXQgdGhpcy5kZWZhdWx0UmVnaW9uKCk7XG4gICAgfVxuXG4gICAgaWYgKGFjY291bnQgPT09IGN4YXBpLlVOS05PV05fQUNDT1VOVCkge1xuICAgICAgYWNjb3VudCA9IGF3YWl0IHRoaXMuZGVmYXVsdEFjY291bnQoKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBV1MgcmVnaW9uIG11c3QgYmUgY29uZmlndXJlZCBlaXRoZXIgd2hlbiB5b3UgY29uZmlndXJlIHlvdXIgQ0RLIHN0YWNrIG9yIHRocm91Z2ggdGhlIGVudmlyb25tZW50YCk7XG4gICAgfVxuXG4gICAgaWYgKCFhY2NvdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byByZXNvbHZlIEFXUyBhY2NvdW50IHRvIHVzZS4gSXQgbXVzdCBiZSBlaXRoZXIgY29uZmlndXJlZCB3aGVuIHlvdSBkZWZpbmUgeW91ciBDREsgb3IgdGhyb3VnaCB0aGUgZW52aXJvbm1lbnRgKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQgPSB7XG4gICAgICByZWdpb24sIGFjY291bnQsIG5hbWU6IGN4YXBpLkVudmlyb25tZW50VXRpbHMuZm9ybWF0KGFjY291bnQsIHJlZ2lvbilcbiAgICB9O1xuXG4gICAgcmV0dXJuIGVudmlyb25tZW50O1xuICB9XG5cbiAgcHJpdmF0ZSBjb25maWd1cmVTREtIdHRwT3B0aW9ucyhvcHRpb25zOiBTREtPcHRpb25zKSB7XG4gICAgY29uc3QgY29uZmlnOiB7W2s6IHN0cmluZ106IGFueX0gPSB7fTtcbiAgICBjb25maWcuaHR0cE9wdGlvbnMgPSB7fTtcblxuICAgIGxldCB1c2VyQWdlbnQgPSBvcHRpb25zLnVzZXJBZ2VudDtcbiAgICBpZiAodXNlckFnZW50ID09IG51bGwpIHtcbiAgICAgIC8vIEZpbmQgdGhlIHBhY2thZ2UuanNvbiBmcm9tIHRoZSBtYWluIHRvb2xraXRcbiAgICAgIGNvbnN0IHBrZyA9IChyZXF1aXJlLm1haW4gYXMgYW55KS5yZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcbiAgICAgIHVzZXJBZ2VudCA9IGAke3BrZy5uYW1lfS8ke3BrZy52ZXJzaW9ufWA7XG4gICAgfVxuICAgIGNvbmZpZy5jdXN0b21Vc2VyQWdlbnQgPSB1c2VyQWdlbnQ7XG5cbiAgICBjb25zdCBwcm94eUFkZHJlc3MgPSBvcHRpb25zLnByb3h5QWRkcmVzcyB8fCBodHRwc1Byb3h5RnJvbUVudmlyb25tZW50KCk7XG4gICAgY29uc3QgY2FCdW5kbGVQYXRoID0gb3B0aW9ucy5jYUJ1bmRsZVBhdGggfHwgY2FCdW5kbGVQYXRoRnJvbUVudmlyb25tZW50KCk7XG5cbiAgICBpZiAocHJveHlBZGRyZXNzICYmIGNhQnVuZGxlUGF0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdCB0aGUgbW9tZW50LCBjYW5ub3Qgc3BlY2lmeSBQcm94eSAoJHtwcm94eUFkZHJlc3N9KSBhbmQgQ0EgQnVuZGxlICgke2NhQnVuZGxlUGF0aH0pIGF0IHRoZSBzYW1lIHRpbWUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvaXNzdWVzLzU4MDRgKTtcbiAgICAgIC8vIE1heWJlIGl0J3MgcG9zc2libGUgYWZ0ZXIgYWxsLCBidXQgSSd2ZSBiZWVuIHN0YXJpbmcgYXRcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Ub29UYWxsTmF0ZS9ub2RlLXByb3h5LWFnZW50L2Jsb2IvbWFzdGVyL2luZGV4LmpzI0w3OVxuICAgICAgLy8gYSB3aGlsZSBub3cgdHJ5aW5nIHRvIGZpZ3VyZSBvdXQgd2hhdCB0byBwYXNzIGluIHNvIHRoYXQgdGhlIHVuZGVybHlpbmcgQWdlbnRcbiAgICAgIC8vIG9iamVjdCB3aWxsIGdldCB0aGUgJ2NhJyBhcmd1bWVudC4gSXQncyBub3QgdHJpdmlhbCBhbmQgSSBkb24ndCB3YW50IHRvIHJpc2sgaXQuXG4gICAgfVxuXG4gICAgaWYgKHByb3h5QWRkcmVzcykgeyAvLyBJZ25vcmUgZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2VcbiAgICAgIC8vIGh0dHBzOi8vYXdzLmFtYXpvbi5jb20vYmxvZ3MvZGV2ZWxvcGVyL3VzaW5nLXRoZS1hd3Mtc2RrLWZvci1qYXZhc2NyaXB0LWZyb20tYmVoaW5kLWEtcHJveHkvXG4gICAgICBkZWJ1ZygnVXNpbmcgcHJveHkgc2VydmVyOiAlcycsIHByb3h5QWRkcmVzcyk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICAgICAgY29uc3QgUHJveHlBZ2VudDogYW55ID0gcmVxdWlyZSgncHJveHktYWdlbnQnKTtcbiAgICAgIGNvbmZpZy5odHRwT3B0aW9ucy5hZ2VudCA9IG5ldyBQcm94eUFnZW50KHByb3h5QWRkcmVzcyk7XG4gICAgfVxuICAgIGlmIChjYUJ1bmRsZVBhdGgpIHtcbiAgICAgIGRlYnVnKCdVc2luZyBDQSBidW5kbGUgcGF0aDogJXMnLCBjYUJ1bmRsZVBhdGgpO1xuICAgICAgY29uZmlnLmh0dHBPcHRpb25zLmFnZW50ID0gbmV3IGh0dHBzLkFnZW50KHtcbiAgICAgICAgY2E6IHJlYWRJZlBvc3NpYmxlKGNhQnVuZGxlUGF0aClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIEFXUy5jb25maWcudXBkYXRlKGNvbmZpZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWNoZSBmb3IgY3JlZGVudGlhbCBwcm92aWRlcnMuXG4gKlxuICogR2l2ZW4gYW4gYWNjb3VudCBhbmQgYW4gb3BlcmF0aW5nIG1vZGUgKHJlYWQgb3Igd3JpdGUpIHdpbGwgcmV0dXJuIGFuXG4gKiBhcHByb3ByaWF0ZSBjcmVkZW50aWFsIHByb3ZpZGVyIGZvciBjcmVkZW50aWFscyBmb3IgdGhlIGdpdmVuIGFjY291bnQuIFRoZVxuICogY3JlZGVudGlhbCBwcm92aWRlciB3aWxsIGJlIGNhY2hlZCBzbyB0aGF0IG11bHRpcGxlIEFXUyBjbGllbnRzIGZvciB0aGUgc2FtZVxuICogZW52aXJvbm1lbnQgd2lsbCBub3QgbWFrZSBtdWx0aXBsZSBuZXR3b3JrIGNhbGxzIHRvIG9idGFpbiBjcmVkZW50aWFscy5cbiAqXG4gKiBXaWxsIHVzZSBkZWZhdWx0IGNyZWRlbnRpYWxzIGlmIHRoZXkgYXJlIGZvciB0aGUgcmlnaHQgYWNjb3VudDsgb3RoZXJ3aXNlLFxuICogYWxsIGxvYWRlZCBjcmVkZW50aWFsIHByb3ZpZGVyIHBsdWdpbnMgd2lsbCBiZSB0cmllZCB0byBvYnRhaW4gY3JlZGVudGlhbHNcbiAqIGZvciB0aGUgZ2l2ZW4gYWNjb3VudC5cbiAqL1xuY2xhc3MgQ3JlZGVudGlhbHNDYWNoZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgY2FjaGU6IHtba2V5OiBzdHJpbmddOiBBV1MuQ3JlZGVudGlhbHN9ID0ge307XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdEF3c0FjY291bnQ6IERlZmF1bHRBV1NBY2NvdW50LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdENyZWRlbnRpYWxQcm92aWRlcjogUHJvbWlzZTxBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4+KSB7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0KGF3c0FjY291bnRJZDogc3RyaW5nIHwgdW5kZWZpbmVkLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuQ3JlZGVudGlhbHM+IHtcbiAgICBjb25zdCBrZXkgPSBgJHthd3NBY2NvdW50SWR9LSR7bW9kZX1gO1xuICAgIGlmICghKGtleSBpbiB0aGlzLmNhY2hlKSkge1xuICAgICAgdGhpcy5jYWNoZVtrZXldID0gYXdhaXQgdGhpcy5nZXRDcmVkZW50aWFscyhhd3NBY2NvdW50SWQsIG1vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWNoZVtrZXldO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRDcmVkZW50aWFscyhhd3NBY2NvdW50SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLkNyZWRlbnRpYWxzPiB7XG4gICAgLy8gSWYgcmVxdWVzdGVkIGFjY291bnQgaXMgdW5kZWZpbmVkIG9yIGVxdWFsIHRvIGRlZmF1bHQgYWNjb3VudCwgdXNlIGRlZmF1bHQgY3JlZGVudGlhbHMgcHJvdmlkZXIuXG4gICAgLy8gKE5vdGUgdGhhdCB3ZSBpZ25vcmUgdGhlIG1vZGUgaW4gdGhpcyBjYXNlLCBpZiB5b3UgcHJlbG9hZGVkIGNyZWRlbnRpYWxzIHRoZXkgYmV0dGVyIGJlIGNvcnJlY3QhKVxuICAgIGNvbnN0IGRlZmF1bHRBY2NvdW50ID0gYXdhaXQgdGhpcy5kZWZhdWx0QXdzQWNjb3VudC5nZXQoKTtcbiAgICBpZiAoIWF3c0FjY291bnRJZCB8fCBhd3NBY2NvdW50SWQgPT09IGRlZmF1bHRBY2NvdW50IHx8IGF3c0FjY291bnRJZCA9PT0gY3hhcGkuVU5LTk9XTl9BQ0NPVU5UKSB7XG4gICAgICBkZWJ1ZyhgVXNpbmcgZGVmYXVsdCBBV1MgU0RLIGNyZWRlbnRpYWxzIGZvciBhY2NvdW50ICR7YXdzQWNjb3VudElkfWApO1xuXG4gICAgICAvLyBDcmVkZW50aWFsUHJvdmlkZXJDaGFpbiBleHRlbmRzIENyZWRlbnRpYWxzLCBidXQgdGhhdCBpcyBhIGxpZS5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLXNkay1qcy9pc3N1ZXMvMjIzNVxuICAgICAgLy8gQ2FsbCByZXNvbHZlKCkgaW5zdGVhZC5cbiAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5kZWZhdWx0Q3JlZGVudGlhbFByb3ZpZGVyKS5yZXNvbHZlUHJvbWlzZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IHRyaWVkU291cmNlczogQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlW10gPSBbXTtcbiAgICAvLyBPdGhlcndpc2UsIGluc3BlY3QgdGhlIHZhcmlvdXMgY3JlZGVudGlhbCBzb3VyY2VzIHdlIGhhdmVcbiAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBQbHVnaW5Ib3N0Lmluc3RhbmNlLmNyZWRlbnRpYWxQcm92aWRlclNvdXJjZXMpIHtcbiAgICAgIGlmICghKGF3YWl0IHNvdXJjZS5pc0F2YWlsYWJsZSgpKSkge1xuICAgICAgICBkZWJ1ZygnQ3JlZGVudGlhbHMgc291cmNlICVzIGlzIG5vdCBhdmFpbGFibGUsIGlnbm9yaW5nIGl0LicsIHNvdXJjZS5uYW1lKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0cmllZFNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgICAgaWYgKCEoYXdhaXQgc291cmNlLmNhblByb3ZpZGVDcmVkZW50aWFscyhhd3NBY2NvdW50SWQpKSkgeyBjb250aW51ZTsgfVxuICAgICAgZGVidWcoYFVzaW5nICR7c291cmNlLm5hbWV9IGNyZWRlbnRpYWxzIGZvciBhY2NvdW50ICR7YXdzQWNjb3VudElkfWApO1xuICAgICAgY29uc3QgcHJvdmlkZXJPckNyZWRzID0gYXdhaXQgc291cmNlLmdldFByb3ZpZGVyKGF3c0FjY291bnRJZCwgbW9kZSk7XG5cbiAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBpZiB0aGUgcGx1Z2luIHJldHVybnMgYSBQcm92aWRlckNoYWluLCByZXNvbHZlIHRoYXQgY2hhaW4uXG4gICAgICAvLyBPdGhlcndpc2UgaXQgbXVzdCBoYXZlIHJldHVybmVkIGNyZWRlbnRpYWxzLlxuICAgICAgaWYgKChwcm92aWRlck9yQ3JlZHMgYXMgYW55KS5yZXNvbHZlUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgKHByb3ZpZGVyT3JDcmVkcyBhcyBhbnkpLnJlc29sdmVQcm9taXNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvdmlkZXJPckNyZWRzO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VOYW1lcyA9IFsnZGVmYXVsdCBjcmVkZW50aWFscyddLmNvbmNhdCh0cmllZFNvdXJjZXMubWFwKHMgPT4gcy5uYW1lKSkuam9pbignLCAnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5lZWQgdG8gcGVyZm9ybSBBV1MgY2FsbHMgZm9yIGFjY291bnQgJHthd3NBY2NvdW50SWR9LCBidXQgbm8gY3JlZGVudGlhbHMgZm91bmQuIFRyaWVkOiAke3NvdXJjZU5hbWVzfS5gKTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHRvIHJldHJpZXZlIHRoZSBhY2NvdW50IGZvciBkZWZhdWx0IGNyZWRlbnRpYWxzIGFuZCBjYWNoZSBpdC5cbiAqXG4gKiBVc2VzIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWxzIHByb3ZpZGVyIHRvIG9idGFpbiBjcmVkZW50aWFscyAoaWYgYXZhaWxhYmxlKSxcbiAqIGFuZCB1c2VzIHRob3NlIGNyZWRlbnRpYWxzIHRvIGNhbGwgU1RTIHRvIHJlcXVlc3QgdGhlIGN1cnJlbnQgYWNjb3VudCBJRC5cbiAqXG4gKiBUaGUgY3JlZGVudGlhbHMgPT4gYWNjb3VudElkIGxvb2t1cCBpcyBjYWNoZWQgb24gZGlzaywgc2luY2UgaXQnc1xuICogZ3VhcmFudGVlZCB0aGF0IGlndmVuIGFjY2VzcyBrZXkgd2lsbCBhbHdheXMgcmVtYWluIGZvciB0aGUgc2FtZSBhY2NvdW50LlxuICovXG5jbGFzcyBEZWZhdWx0QVdTQWNjb3VudCB7XG4gIHByaXZhdGUgZGVmYXVsdEFjY291bnRGZXRjaGVkID0gZmFsc2U7XG4gIHByaXZhdGUgZGVmYXVsdEFjY291bnRJZD86IHN0cmluZyA9IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSByZWFkb25seSBhY2NvdW50Q2FjaGUgPSBuZXcgQWNjb3VudEFjY2Vzc0tleUNhY2hlKCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRDcmVkZW50aWFsc1Byb3ZpZGVyOiBQcm9taXNlPEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbj4sXG4gICAgICBwcml2YXRlIHJlYWRvbmx5IHJlZ2lvbjogKCkgPT4gUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+KSB7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkZWZhdWx0IGFjY291bnRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXQoKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICBpZiAoIXRoaXMuZGVmYXVsdEFjY291bnRGZXRjaGVkKSB7XG4gICAgICB0aGlzLmRlZmF1bHRBY2NvdW50SWQgPSBhd2FpdCB0aGlzLmxvb2t1cERlZmF1bHRBY2NvdW50KCk7XG4gICAgICB0aGlzLmRlZmF1bHRBY2NvdW50RmV0Y2hlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRlZmF1bHRBY2NvdW50SWQ7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxvb2t1cERlZmF1bHRBY2NvdW50KCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZXJlIGp1c3QgaXMgKk5PKiB3YXkgdG8gZG8gQXNzdW1lUm9sZSBjcmVkZW50aWFscyBhcyBsb25nIGFzIEFXU19TREtfTE9BRF9DT05GSUcgaXMgbm90IHNldC4gVGhlIFNES1xuICAgICAgLy8gY3Jhc2ggaWYgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3QgdGhvdWdoLiBTbyBzZXQgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIGlmIHdlIGNhbiBmaW5kIHRoYXQgZmlsZS5cbiAgICAgIGF3YWl0IHNldENvbmZpZ1ZhcmlhYmxlKCk7XG5cbiAgICAgIGRlYnVnKCdSZXNvbHZpbmcgZGVmYXVsdCBjcmVkZW50aWFscycpO1xuICAgICAgY29uc3QgY3JlZGVudGlhbFByb3ZpZGVyID0gYXdhaXQgdGhpcy5kZWZhdWx0Q3JlZGVudGlhbHNQcm92aWRlcjtcbiAgICAgIGNvbnN0IGNyZWRzID0gYXdhaXQgY3JlZGVudGlhbFByb3ZpZGVyLnJlc29sdmVQcm9taXNlKCk7XG5cbiAgICAgIGNvbnN0IGFjY2Vzc0tleUlkID0gY3JlZHMuYWNjZXNzS2V5SWQ7XG4gICAgICBpZiAoIWFjY2Vzc0tleUlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHJlc29sdmUgQVdTIGNyZWRlbnRpYWxzIChzZXR1cCB3aXRoIFwiYXdzIGNvbmZpZ3VyZVwiKScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhY2NvdW50SWQgPSBhd2FpdCB0aGlzLmFjY291bnRDYWNoZS5mZXRjaChjcmVkcy5hY2Nlc3NLZXlJZCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIG9uZSwgcmVzb2x2ZSBmcm9tIFNUUyBhbmQgc3RvcmUgaW4gY2FjaGUuXG4gICAgICAgIGRlYnVnKCdMb29raW5nIHVwIGRlZmF1bHQgYWNjb3VudCBJRCBmcm9tIFNUUycpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXcgQVdTLlNUUyh7IGNyZWRlbnRpYWxzOiBjcmVkcywgcmVnaW9uOiBhd2FpdCB0aGlzLnJlZ2lvbigpIH0pLmdldENhbGxlcklkZW50aXR5KCkucHJvbWlzZSgpO1xuICAgICAgICBjb25zdCBhaWQgPSByZXN1bHQuQWNjb3VudDtcbiAgICAgICAgaWYgKCFhaWQpIHtcbiAgICAgICAgICBkZWJ1ZygnU1RTIGRpZG5cXCd0IHJldHVybiBhbiBhY2NvdW50IElEJyk7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZygnRGVmYXVsdCBhY2NvdW50IElEOicsIGFpZCk7XG4gICAgICAgIHJldHVybiBhaWQ7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGFjY291bnRJZDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygnVW5hYmxlIHRvIGRldGVybWluZSB0aGUgZGVmYXVsdCBBV1MgYWNjb3VudCAoZGlkIHlvdSBjb25maWd1cmUgXCJhd3MgY29uZmlndXJlXCI/KTonLCBlKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQnVpbGQgYW4gQVdTIENMSS1jb21wYXRpYmxlIGNyZWRlbnRpYWwgY2hhaW4gcHJvdmlkZXJcbiAqXG4gKiBUaGlzIGlzIHNpbWlsYXIgdG8gdGhlIGRlZmF1bHQgY3JlZGVudGlhbCBwcm92aWRlciBjaGFpbiBjcmVhdGVkIGJ5IHRoZSBTREtcbiAqIGV4Y2VwdCBpdCBhbHNvIGFjY2VwdHMgdGhlIHByb2ZpbGUgYXJndW1lbnQgaW4gdGhlIGNvbnN0cnVjdG9yIChub3QganVzdCBmcm9tXG4gKiB0aGUgZW52aXJvbm1lbnQpLlxuICpcbiAqIFRvIG1pbWljIHRoZSBBV1MgQ0xJIGJlaGF2aW9yOlxuICpcbiAqIC0gd2UgZGVmYXVsdCB0byB+Ly5hd3MvY3JlZGVudGlhbHMgaWYgZW52aXJvbm1lbnQgdmFyaWFibGUgZm9yIGNyZWRlbnRpYWxzXG4gKiBmaWxlIGxvY2F0aW9uIGlzIG5vdCBnaXZlbiAoU0RLIGV4cGVjdHMgZXhwbGljaXQgZW52aXJvbm1lbnQgdmFyaWFibGUgd2l0aCBuYW1lKS5cbiAqIC0gQVdTX0RFRkFVTFRfUFJPRklMRSBpcyBhbHNvIGluc3BlY3RlZCBmb3IgcHJvZmlsZSBuYW1lIChub3QganVzdCBBV1NfUFJPRklMRSkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1ha2VDTElDb21wYXRpYmxlQ3JlZGVudGlhbFByb3ZpZGVyKHByb2ZpbGU6IHN0cmluZyB8IHVuZGVmaW5lZCwgZWMyY3JlZHM6IGJvb2xlYW4gfCB1bmRlZmluZWQpIHtcbiAgcHJvZmlsZSA9IHByb2ZpbGUgfHwgcHJvY2Vzcy5lbnYuQVdTX1BST0ZJTEUgfHwgcHJvY2Vzcy5lbnYuQVdTX0RFRkFVTFRfUFJPRklMRSB8fCAnZGVmYXVsdCc7XG5cbiAgLy8gTmVlZCB0byBjb25zdHJ1Y3QgZmlsZW5hbWUgb3Vyc2VsdmVzLCB3aXRob3V0IGFwcHJvcHJpYXRlIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAvLyBubyBkZWZhdWx0cyB1c2VkIGJ5IEpTIFNESy5cbiAgY29uc3QgZmlsZW5hbWUgPSBwcm9jZXNzLmVudi5BV1NfU0hBUkVEX0NSRURFTlRJQUxTX0ZJTEUgfHwgcGF0aC5qb2luKG9zLmhvbWVkaXIoKSwgJy5hd3MnLCAnY3JlZGVudGlhbHMnKTtcblxuICBjb25zdCBzb3VyY2VzID0gW1xuICAgICgpID0+IG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQVdTJyksXG4gICAgKCkgPT4gbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBTUFaT04nKSxcbiAgXTtcbiAgaWYgKGZzLnBhdGhFeGlzdHMoZmlsZW5hbWUpKSB7XG4gICAgc291cmNlcy5wdXNoKCgpID0+IG5ldyBBV1MuU2hhcmVkSW5pRmlsZUNyZWRlbnRpYWxzKHsgcHJvZmlsZSwgZmlsZW5hbWUgfSkpO1xuICB9XG5cbiAgaWYgKGhhc0Vjc0NyZWRlbnRpYWxzKCkpIHtcbiAgICBzb3VyY2VzLnB1c2goKCkgPT4gbmV3IEFXUy5FQ1NDcmVkZW50aWFscygpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbHNlIGlmOiBkb24ndCBnZXQgRUMyIGNyZWRzIGlmIHdlIHNob3VsZCBoYXZlIGdvdHRlbiBFQ1MgY3JlZHMtLUVDUyBpbnN0YW5jZXMgYWxzb1xuICAgIC8vIHJ1biBvbiBFQzIgYm94ZXMgYnV0IHRoZSBjcmVkcyByZXByZXNlbnQgc29tZXRoaW5nIGRpZmZlcmVudC4gU2FtZSBiZWhhdmlvciBhc1xuICAgIC8vIHVwc3RyZWFtIGNvZGUuXG5cbiAgICBpZiAoZWMyY3JlZHMgPT09IHVuZGVmaW5lZCkgeyBlYzJjcmVkcyA9IGF3YWl0IGhhc0VjMkNyZWRlbnRpYWxzKCk7IH1cblxuICAgIGlmIChlYzJjcmVkcykge1xuICAgICAgc291cmNlcy5wdXNoKCgpID0+IG5ldyBBV1MuRUMyTWV0YWRhdGFDcmVkZW50aWFscygpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbihzb3VyY2VzKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGRlZmF1bHQgcmVnaW9uIGluIGEgQ0xJLWNvbXBhdGlibGUgd2F5XG4gKlxuICogTW9zdGx5IGNvcGllZCBmcm9tIG5vZGVfbG9hZGVyLmpzLCBidXQgd2l0aCB0aGUgZm9sbG93aW5nIGRpZmZlcmVuY2VzOlxuICpcbiAqIC0gVGFrZXMgYSBydW50aW1lIHByb2ZpbGUgbmFtZSB0byBsb2FkIHRoZSByZWdpb24gZnJvbSwgbm90IGp1c3QgYmFzZWQgb24gZW52aXJvbm1lbnRcbiAqICAgdmFyaWFibGVzIGF0IHByb2Nlc3Mgc3RhcnQuXG4gKiAtIFdlIGhhdmUgbmVlZGVkIHRvIGNyZWF0ZSBhIGxvY2FsIGNvcHkgb2YgdGhlIFNoYXJlZEluaUZpbGUgY2xhc3MgYmVjYXVzZSB0aGVcbiAqICAgaW1wbGVtZW50YXRpb24gaW4gJ2F3cy1zZGsnIGlzIHByaXZhdGUgKGFuZCB0aGUgZGVmYXVsdCB1c2Ugb2YgaXQgaW4gdGhlXG4gKiAgIFNESyBkb2VzIG5vdCBhbGxvdyB1cyB0byBzcGVjaWZ5IGEgcHJvZmlsZSBhdCBydW50aW1lKS5cbiAqIC0gQVdTX0RFRkFVTFRfUFJPRklMRSBhbmQgQVdTX0RFRkFVTFRfUkVHSU9OIGFyZSBhbHNvIHVzZWQgYXMgZW52aXJvbm1lbnRcbiAqICAgdmFyaWFibGVzIHRvIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSByZWdpb24uXG4gKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGludm9rZWQgdG8gcmV0cmlldmUgdGhlIGFjdHVhbCByZWdpb24gdmFsdWVcbiAqICh1c2VkIHRvIGJlIGp1c3QgYSBwcm9taXNlLCBidXQgdGhhdCB3b3VsZCBsZWFkIHRvIGZpcmluZyBvZmYgYSBmYWlsaW5nXG4gKiBvcGVyYXRpb24gYW5kIGlmIGl0IHdhcyBuZXZlciBhd2FpdGVkIE5vZGVKUyB3b3VsZCBjb21wbGFpbikuXG4gKi9cbmZ1bmN0aW9uIGdldENMSUNvbXBhdGlibGVEZWZhdWx0UmVnaW9uR2V0dGVyKHByb2ZpbGU6IHN0cmluZyB8IHVuZGVmaW5lZCk6ICgpID0+IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gIGxldCByZXRyaWV2ZWQgPSBmYWxzZTtcbiAgbGV0IHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghcmV0cmlldmVkKSB7XG4gICAgICBwcm9maWxlID0gcHJvZmlsZSB8fCBwcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCBwcm9jZXNzLmVudi5BV1NfREVGQVVMVF9QUk9GSUxFIHx8ICdkZWZhdWx0JztcblxuICAgICAgLy8gRGVmYXVsdHMgaW5zaWRlIGNvbnN0cnVjdG9yXG4gICAgICBjb25zdCB0b0NoZWNrID0gW1xuICAgICAgICB7ZmlsZW5hbWU6IHByb2Nlc3MuZW52LkFXU19TSEFSRURfQ1JFREVOVElBTFNfRklMRSB9LFxuICAgICAgICB7aXNDb25maWc6IHRydWUsIGZpbGVuYW1lOiBwcm9jZXNzLmVudi5BV1NfQ09ORklHX0ZJTEV9LFxuICAgICAgXTtcblxuICAgICAgcmVnaW9uID0gcHJvY2Vzcy5lbnYuQVdTX1JFR0lPTiB8fCBwcm9jZXNzLmVudi5BTUFaT05fUkVHSU9OIHx8XG4gICAgICAgIHByb2Nlc3MuZW52LkFXU19ERUZBVUxUX1JFR0lPTiB8fCBwcm9jZXNzLmVudi5BTUFaT05fREVGQVVMVF9SRUdJT047XG5cbiAgICAgIHdoaWxlICghcmVnaW9uICYmIHRvQ2hlY2subGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBjb25maWdGaWxlID0gbmV3IFNoYXJlZEluaUZpbGUodG9DaGVjay5zaGlmdCgpKTtcbiAgICAgICAgY29uc3Qgc2VjdGlvbiA9IGF3YWl0IGNvbmZpZ0ZpbGUuZ2V0UHJvZmlsZShwcm9maWxlKTtcbiAgICAgICAgcmVnaW9uID0gc2VjdGlvbiAmJiBzZWN0aW9uLnJlZ2lvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZWdpb24pIHtcbiAgICAgICAgY29uc3QgdXNlZFByb2ZpbGUgPSAhcHJvZmlsZSA/ICcnIDogYCAocHJvZmlsZTogXCIke3Byb2ZpbGV9XCIpYDtcbiAgICAgICAgZGVidWcoYFVuYWJsZSB0byBkZXRlcm1pbmUgQVdTIHJlZ2lvbiBmcm9tIGVudmlyb25tZW50IG9yIEFXUyBjb25maWd1cmF0aW9uJHt1c2VkUHJvZmlsZX1gKTtcbiAgICAgIH1cblxuICAgICAgcmV0cmlldmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnaW9uO1xuICB9O1xufVxuXG4vKipcbiAqIEZpbmQgYW5kIHJldHVybiB0aGUgY29uZmlndXJlZCBIVFRQUyBwcm94eSBhZGRyZXNzXG4gKi9cbmZ1bmN0aW9uIGh0dHBzUHJveHlGcm9tRW52aXJvbm1lbnQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5KSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5O1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5IVFRQU19QUk9YWSkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5IVFRQU19QUk9YWTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEZpbmQgYW5kIHJldHVybiBhIENBIGNlcnRpZmljYXRlIGJ1bmRsZSBwYXRoIHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBTREsuXG4gKi9cbmZ1bmN0aW9uIGNhQnVuZGxlUGF0aEZyb21FbnZpcm9ubWVudCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAocHJvY2Vzcy5lbnYuYXdzX2NhX2J1bmRsZSkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5hd3NfY2FfYnVuZGxlO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5BV1NfQ0FfQlVORExFKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkFXU19DQV9CVU5ETEU7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBpdCBsb29rcyBsaWtlIHdlJ2xsIGhhdmUgRUNTIGNyZWRlbnRpYWxzIGF2YWlsYWJsZVxuICovXG5mdW5jdGlvbiBoYXNFY3NDcmVkZW50aWFscygpIHtcbiAgcmV0dXJuIChBV1MuRUNTQ3JlZGVudGlhbHMucHJvdG90eXBlIGFzIGFueSkuaXNDb25maWd1cmVkRm9yRWNzQ3JlZGVudGlhbHMoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciB3ZSdyZSBvbiBhbiBFQzIgaW5zdGFuY2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaGFzRWMyQ3JlZGVudGlhbHMoKSB7XG4gIGRlYnVnKFwiRGV0ZXJtaW5pbmcgd2hldGhlciB3ZSdyZSBvbiBhbiBFQzIgaW5zdGFuY2UuXCIpO1xuXG4gIGxldCBpbnN0YW5jZSA9IGZhbHNlO1xuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BV1NFQzIvbGF0ZXN0L1dpbmRvd3NHdWlkZS9pZGVudGlmeV9lYzJfaW5zdGFuY2VzLmh0bWxcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1dGlsLnByb21pc2lmeShjaGlsZF9wcm9jZXNzLmV4ZWMpKCd3bWljIHBhdGggd2luMzJfY29tcHV0ZXJzeXN0ZW1wcm9kdWN0IGdldCB1dWlkJywgeyBlbmNvZGluZzogJ3V0Zi04JyB9KTtcbiAgICAvLyBvdXRwdXQgbG9va3MgbGlrZVxuICAgIC8vICBVVUlEXG4gICAgLy8gIEVDMkFFMTQ1LUQxREMtMTNCMi05NEVELTAxMjM0QUJDREVGXG4gICAgY29uc3QgbGluZXMgPSByZXN1bHQuc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgIGluc3RhbmNlID0gbGluZXMuc29tZSh4ID0+IG1hdGNoZXNSZWdleCgvXmVjMi9pLCB4KSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0VDMi9sYXRlc3QvVXNlckd1aWRlL2lkZW50aWZ5X2VjMl9pbnN0YW5jZXMuaHRtbFxuICAgIGNvbnN0IGZpbGVzOiBBcnJheTxbc3RyaW5nLCBSZWdFeHBdPiA9IFtcbiAgICAgIC8vIFRoaXMgcmVjb2duaXplcyB0aGUgWGVuIGh5cGVydmlzb3IgYmFzZWQgaW5zdGFuY2VzIChwcmUtNXRoIGdlbilcbiAgICAgIFsnL3N5cy9oeXBlcnZpc29yL3V1aWQnLCAvXmVjMi9pXSxcblxuICAgICAgLy8gVGhpcyByZWNvZ25pemVzIHRoZSBuZXcgSHlwZXJ2aXNvciAoNXRoLWdlbiBpbnN0YW5jZXMgYW5kIGhpZ2hlcilcbiAgICAgIC8vIENhbid0IHVzZSB0aGUgYWR2ZXJ0aXNlZCBmaWxlICcvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvcHJvZHVjdF91dWlkJyBiZWNhdXNlIGl0IHJlcXVpcmVzIHJvb3QgdG8gcmVhZC5cbiAgICAgIC8vIEluc3RlYWQsIHN5c192ZW5kb3IgY29udGFpbnMgc29tZXRoaW5nIGxpa2UgJ0FtYXpvbiBFQzInLlxuICAgICAgWycvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvc3lzX3ZlbmRvcicsIC9lYzIvaV0sXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IFtmaWxlLCByZV0gb2YgZmlsZXMpIHtcbiAgICAgIGlmIChtYXRjaGVzUmVnZXgocmUsIHJlYWRJZlBvc3NpYmxlKGZpbGUpKSkge1xuICAgICAgICBpbnN0YW5jZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRlYnVnKGluc3RhbmNlID8gJ0xvb2tzIGxpa2UgRUMyIGluc3RhbmNlLicgOiAnRG9lcyBub3QgbG9vayBsaWtlIEVDMiBpbnN0YW5jZS4nKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5hc3luYyBmdW5jdGlvbiBzZXRDb25maWdWYXJpYWJsZSgpIHtcbiAgY29uc3QgaG9tZURpciA9IHByb2Nlc3MuZW52LkhPTUUgfHwgcHJvY2Vzcy5lbnYuVVNFUlBST0ZJTEVcbiAgICB8fCAocHJvY2Vzcy5lbnYuSE9NRVBBVEggPyAoKHByb2Nlc3MuZW52LkhPTUVEUklWRSB8fCAnQzovJykgKyBwcm9jZXNzLmVudi5IT01FUEFUSCkgOiBudWxsKSB8fCBvcy5ob21lZGlyKCk7XG5cbiAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMocGF0aC5yZXNvbHZlKGhvbWVEaXIsICcuYXdzJywgJ2NvbmZpZycpKSkge1xuICAgIHByb2Nlc3MuZW52LkFXU19TREtfTE9BRF9DT05GSUcgPSAnMSc7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWFkIGEgZmlsZSBpZiBpdCBleGlzdHMsIG9yIHJldHVybiB1bmRlZmluZWRcbiAqXG4gKiBOb3QgYXN5bmMgYmVjYXVzZSBpdCBpcyB1c2VkIGluIHRoZSBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiByZWFkSWZQb3NzaWJsZShmaWxlbmFtZTogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgdHJ5IHtcbiAgICBpZiAoIWZzLnBhdGhFeGlzdHNTeW5jKGZpbGVuYW1lKSkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhmaWxlbmFtZSwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKGUpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hlc1JlZ2V4KHJlOiBSZWdFeHAsIHM6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICByZXR1cm4gcyAhPT0gdW5kZWZpbmVkICYmIHJlLmV4ZWMocykgIT09IG51bGw7XG59XG4iXX0=