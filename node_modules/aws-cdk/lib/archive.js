"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const archiver = require("archiver");
const crypto = require("crypto");
const fs = require("fs-extra");
const glob = require("glob");
const path = require("path");
function zipDirectory(directory, outputFile) {
    return new Promise(async (ok, fail) => {
        // The below options are needed to support following symlinks when building zip files:
        // - nodir: This will prevent symlinks themselves from being copied into the zip.
        // - follow: This will follow symlinks and copy the files within.
        const globOptions = {
            dot: true,
            nodir: true,
            follow: true,
            cwd: directory,
        };
        const files = glob.sync('**', globOptions); // The output here is already sorted
        const output = fs.createWriteStream(outputFile);
        const archive = archiver('zip');
        archive.on('warning', fail);
        archive.on('error', fail);
        archive.pipe(output);
        // Append files serially to ensure file order
        for (const file of files) {
            const fullPath = path.join(directory, file);
            const [data, stat] = await Promise.all([fs.readFile(fullPath), fs.stat(fullPath)]);
            archive.append(data, {
                name: file,
                date: new Date('1980-01-01T00:00:00.000Z'),
                mode: stat.mode,
            });
        }
        archive.finalize();
        // archive has been finalized and the output file descriptor has closed, resolve promise
        output.once('close', () => ok());
    });
}
exports.zipDirectory = zipDirectory;
function contentHash(data) {
    return crypto.createHash('sha256').update(data).digest('hex');
}
exports.contentHash = contentHash;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJjaGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImFyY2hpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxxQ0FBcUM7QUFDckMsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBRTdCLFNBQWdCLFlBQVksQ0FBQyxTQUFpQixFQUFFLFVBQWtCO0lBQ2hFLE9BQU8sSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRTtRQUNwQyxzRkFBc0Y7UUFDdEYsaUZBQWlGO1FBQ2pGLGlFQUFpRTtRQUNqRSxNQUFNLFdBQVcsR0FBRztZQUNsQixHQUFHLEVBQUUsSUFBSTtZQUNULEtBQUssRUFBRSxJQUFJO1lBQ1gsTUFBTSxFQUFFLElBQUk7WUFDWixHQUFHLEVBQUUsU0FBUztTQUNmLENBQUM7UUFDRixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDLG9DQUFvQztRQUVoRixNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFaEQsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2hDLE9BQU8sQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzVCLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzFCLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFckIsNkNBQTZDO1FBQzdDLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFO1lBQ3hCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzVDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNuRixPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRTtnQkFDbkIsSUFBSSxFQUFFLElBQUk7Z0JBQ1YsSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDLDBCQUEwQixDQUFDO2dCQUMxQyxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7YUFDaEIsQ0FBQyxDQUFDO1NBQ0o7UUFFRCxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFbkIsd0ZBQXdGO1FBQ3hGLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDbkMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBcENELG9DQW9DQztBQUVELFNBQWdCLFdBQVcsQ0FBQyxJQUFnQztJQUMxRCxPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNoRSxDQUFDO0FBRkQsa0NBRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhcmNoaXZlciBmcm9tICdhcmNoaXZlcic7XG5pbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIGdsb2IgZnJvbSAnZ2xvYic7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5leHBvcnQgZnVuY3Rpb24gemlwRGlyZWN0b3J5KGRpcmVjdG9yeTogc3RyaW5nLCBvdXRwdXRGaWxlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChvaywgZmFpbCkgPT4ge1xuICAgIC8vIFRoZSBiZWxvdyBvcHRpb25zIGFyZSBuZWVkZWQgdG8gc3VwcG9ydCBmb2xsb3dpbmcgc3ltbGlua3Mgd2hlbiBidWlsZGluZyB6aXAgZmlsZXM6XG4gICAgLy8gLSBub2RpcjogVGhpcyB3aWxsIHByZXZlbnQgc3ltbGlua3MgdGhlbXNlbHZlcyBmcm9tIGJlaW5nIGNvcGllZCBpbnRvIHRoZSB6aXAuXG4gICAgLy8gLSBmb2xsb3c6IFRoaXMgd2lsbCBmb2xsb3cgc3ltbGlua3MgYW5kIGNvcHkgdGhlIGZpbGVzIHdpdGhpbi5cbiAgICBjb25zdCBnbG9iT3B0aW9ucyA9IHtcbiAgICAgIGRvdDogdHJ1ZSxcbiAgICAgIG5vZGlyOiB0cnVlLFxuICAgICAgZm9sbG93OiB0cnVlLFxuICAgICAgY3dkOiBkaXJlY3RvcnksXG4gICAgfTtcbiAgICBjb25zdCBmaWxlcyA9IGdsb2Iuc3luYygnKionLCBnbG9iT3B0aW9ucyk7IC8vIFRoZSBvdXRwdXQgaGVyZSBpcyBhbHJlYWR5IHNvcnRlZFxuXG4gICAgY29uc3Qgb3V0cHV0ID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0ob3V0cHV0RmlsZSk7XG5cbiAgICBjb25zdCBhcmNoaXZlID0gYXJjaGl2ZXIoJ3ppcCcpO1xuICAgIGFyY2hpdmUub24oJ3dhcm5pbmcnLCBmYWlsKTtcbiAgICBhcmNoaXZlLm9uKCdlcnJvcicsIGZhaWwpO1xuICAgIGFyY2hpdmUucGlwZShvdXRwdXQpO1xuXG4gICAgLy8gQXBwZW5kIGZpbGVzIHNlcmlhbGx5IHRvIGVuc3VyZSBmaWxlIG9yZGVyXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXJlY3RvcnksIGZpbGUpO1xuICAgICAgY29uc3QgW2RhdGEsIHN0YXRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW2ZzLnJlYWRGaWxlKGZ1bGxQYXRoKSwgZnMuc3RhdChmdWxsUGF0aCldKTtcbiAgICAgIGFyY2hpdmUuYXBwZW5kKGRhdGEsIHtcbiAgICAgICAgbmFtZTogZmlsZSxcbiAgICAgICAgZGF0ZTogbmV3IERhdGUoJzE5ODAtMDEtMDFUMDA6MDA6MDAuMDAwWicpLCAvLyByZXNldCBkYXRlcyB0byBnZXQgdGhlIHNhbWUgaGFzaCBmb3IgdGhlIHNhbWUgY29udGVudFxuICAgICAgICBtb2RlOiBzdGF0Lm1vZGUsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBhcmNoaXZlLmZpbmFsaXplKCk7XG5cbiAgICAvLyBhcmNoaXZlIGhhcyBiZWVuIGZpbmFsaXplZCBhbmQgdGhlIG91dHB1dCBmaWxlIGRlc2NyaXB0b3IgaGFzIGNsb3NlZCwgcmVzb2x2ZSBwcm9taXNlXG4gICAgb3V0cHV0Lm9uY2UoJ2Nsb3NlJywgKCkgPT4gb2soKSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udGVudEhhc2goZGF0YTogc3RyaW5nIHwgQnVmZmVyIHwgRGF0YVZpZXcpIHtcbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoZGF0YSkuZGlnZXN0KCdoZXgnKTtcbn1cbiJdfQ==