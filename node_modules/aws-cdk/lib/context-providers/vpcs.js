"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const api_1 = require("../api");
const logging_1 = require("../logging");
class VpcNetworkContextProviderPlugin {
    constructor(aws) {
        this.aws = aws;
    }
    async getValue(args) {
        const account = args.account;
        const region = args.region;
        const ec2 = await this.aws.ec2(account, region, api_1.Mode.ForReading);
        const vpcId = await this.findVpc(ec2, args);
        return await this.readVpcProps(ec2, vpcId, args);
    }
    async findVpc(ec2, args) {
        // Build request filter (map { Name -> Value } to list of [{ Name, Values }])
        const filters = Object.entries(args.filter).map(([tag, value]) => ({ Name: tag, Values: [value] }));
        logging_1.debug(`Listing VPCs in ${args.account}:${args.region}`);
        const response = await ec2.describeVpcs({ Filters: filters }).promise();
        const vpcs = response.Vpcs || [];
        if (vpcs.length === 0) {
            throw new Error(`Could not find any VPCs matching ${JSON.stringify(args)}`);
        }
        if (vpcs.length > 1) {
            throw new Error(`Found ${vpcs.length} VPCs matching ${JSON.stringify(args)}; please narrow the search criteria`);
        }
        return vpcs[0];
    }
    async readVpcProps(ec2, vpc, args) {
        const vpcId = vpc.VpcId;
        logging_1.debug(`Describing VPC ${vpcId}`);
        const filters = { Filters: [{ Name: 'vpc-id', Values: [vpcId] }] };
        const subnetsResponse = await ec2.describeSubnets(filters).promise();
        const listedSubnets = subnetsResponse.Subnets || [];
        const routeTablesResponse = await ec2.describeRouteTables(filters).promise();
        const routeTables = new RouteTables(routeTablesResponse.RouteTables || []);
        // Now comes our job to separate these subnets out into AZs and subnet groups (Public, Private, Isolated)
        // We have the following attributes to go on:
        // - Type tag, we tag subnets with their type. In absence of this tag, we
        //   fall back to MapPublicIpOnLaunch => must be a Public subnet, anything
        //   else is considered Priate.
        // - Name tag, we tag subnets with their subnet group name. In absence of this tag,
        //   we use the type as the name.
        const azs = Array.from(new Set(listedSubnets.map(s => s.AvailabilityZone)));
        azs.sort();
        const subnets = listedSubnets.map(subnet => {
            let type = getTag('aws-cdk:subnet-type', subnet.Tags);
            if (type === undefined && subnet.MapPublicIpOnLaunch) {
                type = SubnetType.Public;
            }
            if (type === undefined && routeTables.hasRouteToIgw(subnet.SubnetId)) {
                type = SubnetType.Public;
            }
            if (type === undefined) {
                type = SubnetType.Private;
            }
            if (!isValidSubnetType(type)) {
                // tslint:disable-next-line: max-line-length
                throw new Error(`Subnet ${subnet.SubnetArn} has invalid subnet type ${type} (must be ${SubnetType.Public}, ${SubnetType.Private} or ${SubnetType.Isolated})`);
            }
            const name = getTag(args.subnetGroupNameTag || 'aws-cdk:subnet-name', subnet.Tags) || type;
            const routeTableId = routeTables.routeTableIdForSubnetId(subnet.SubnetId);
            if (!routeTableId) {
                throw new Error(`Subnet ${subnet.SubnetArn} does not have an associated route table (and there is no "main" table)`);
            }
            return {
                az: subnet.AvailabilityZone,
                cidr: subnet.CidrBlock,
                type,
                name,
                subnetId: subnet.SubnetId,
                routeTableId,
            };
        });
        let grouped;
        let assymetricSubnetGroups;
        if (args.returnAsymmetricSubnets) {
            grouped = { azs: [], groups: [] };
            assymetricSubnetGroups = groupAsymmetricSubnets(subnets);
        }
        else {
            grouped = groupSubnets(subnets);
            assymetricSubnetGroups = undefined;
        }
        // Find attached+available VPN gateway for this VPC
        const vpnGatewayResponse = await ec2.describeVpnGateways({
            Filters: [
                {
                    Name: 'attachment.vpc-id',
                    Values: [vpcId]
                },
                {
                    Name: 'attachment.state',
                    Values: ['attached']
                },
                {
                    Name: 'state',
                    Values: ['available']
                }
            ]
        }).promise();
        const vpnGatewayId = vpnGatewayResponse.VpnGateways && vpnGatewayResponse.VpnGateways.length === 1
            ? vpnGatewayResponse.VpnGateways[0].VpnGatewayId
            : undefined;
        return {
            vpcId,
            vpcCidrBlock: vpc.CidrBlock,
            availabilityZones: grouped.azs,
            isolatedSubnetIds: collapse(flatMap(findGroups(SubnetType.Isolated, grouped), group => group.subnets.map(s => s.subnetId))),
            isolatedSubnetNames: collapse(flatMap(findGroups(SubnetType.Isolated, grouped), group => group.name ? [group.name] : [])),
            isolatedSubnetRouteTableIds: collapse(flatMap(findGroups(SubnetType.Isolated, grouped), group => group.subnets.map(s => s.routeTableId))),
            privateSubnetIds: collapse(flatMap(findGroups(SubnetType.Private, grouped), group => group.subnets.map(s => s.subnetId))),
            privateSubnetNames: collapse(flatMap(findGroups(SubnetType.Private, grouped), group => group.name ? [group.name] : [])),
            privateSubnetRouteTableIds: collapse(flatMap(findGroups(SubnetType.Private, grouped), group => group.subnets.map(s => s.routeTableId))),
            publicSubnetIds: collapse(flatMap(findGroups(SubnetType.Public, grouped), group => group.subnets.map(s => s.subnetId))),
            publicSubnetNames: collapse(flatMap(findGroups(SubnetType.Public, grouped), group => group.name ? [group.name] : [])),
            publicSubnetRouteTableIds: collapse(flatMap(findGroups(SubnetType.Public, grouped), group => group.subnets.map(s => s.routeTableId))),
            vpnGatewayId,
            subnetGroups: assymetricSubnetGroups,
        };
    }
}
exports.VpcNetworkContextProviderPlugin = VpcNetworkContextProviderPlugin;
class RouteTables {
    constructor(tables) {
        this.tables = tables;
        this.mainRouteTable = this.tables.find(table => !!table.Associations && table.Associations.some(assoc => !!assoc.Main));
    }
    routeTableIdForSubnetId(subnetId) {
        const table = this.tableForSubnet(subnetId);
        return (table && table.RouteTableId) || (this.mainRouteTable && this.mainRouteTable.RouteTableId);
    }
    /**
     * Whether the given subnet has a route to an IGW
     */
    hasRouteToIgw(subnetId) {
        const table = this.tableForSubnet(subnetId);
        return !!table && !!table.Routes && table.Routes.some(route => !!route.GatewayId && route.GatewayId.startsWith('igw-'));
    }
    tableForSubnet(subnetId) {
        return this.tables.find(table => !!table.Associations && table.Associations.some(assoc => assoc.SubnetId === subnetId));
    }
}
/**
 * Return the value of a tag from a set of tags
 */
function getTag(name, tags) {
    for (const tag of tags || []) {
        if (tag.Key === name) {
            return tag.Value;
        }
    }
    return undefined;
}
/**
 * Group subnets of the same type together, and order by AZ
 */
function groupSubnets(subnets) {
    const grouping = {};
    for (const subnet of subnets) {
        const key = [subnet.type, subnet.name].toString();
        if (!(key in grouping)) {
            grouping[key] = [];
        }
        grouping[key].push(subnet);
    }
    const groups = Object.values(grouping).map(sns => {
        sns.sort((a, b) => a.az.localeCompare(b.az));
        return {
            type: sns[0].type,
            name: sns[0].name,
            subnets: sns,
        };
    });
    const azs = groups[0].subnets.map(s => s.az);
    for (const group of groups) {
        const groupAZs = group.subnets.map(s => s.az);
        if (!arraysEqual(groupAZs, azs)) {
            throw new Error(`Not all subnets in VPC have the same AZs: ${groupAZs} vs ${azs}`);
        }
    }
    return { azs, groups };
}
function groupAsymmetricSubnets(subnets) {
    const grouping = {};
    for (const subnet of subnets) {
        const key = [subnet.type, subnet.name].toString();
        if (!(key in grouping)) {
            grouping[key] = [];
        }
        grouping[key].push(subnet);
    }
    return Object.values(grouping).map(subnetArray => {
        subnetArray.sort((subnet1, subnet2) => subnet1.az.localeCompare(subnet2.az));
        return {
            name: subnetArray[0].name,
            type: subnetTypeToVpcSubnetType(subnetArray[0].type),
            subnets: subnetArray.map(subnet => ({
                subnetId: subnet.subnetId,
                cidr: subnet.cidr,
                availabilityZone: subnet.az,
                routeTableId: subnet.routeTableId,
            })),
        };
    });
}
function subnetTypeToVpcSubnetType(type) {
    switch (type) {
        case SubnetType.Isolated: return cxapi.VpcSubnetGroupType.ISOLATED;
        case SubnetType.Private: return cxapi.VpcSubnetGroupType.PRIVATE;
        case SubnetType.Public: return cxapi.VpcSubnetGroupType.PUBLIC;
    }
}
var SubnetType;
(function (SubnetType) {
    SubnetType["Public"] = "Public";
    SubnetType["Private"] = "Private";
    SubnetType["Isolated"] = "Isolated";
})(SubnetType || (SubnetType = {}));
function isValidSubnetType(val) {
    return val === SubnetType.Public
        || val === SubnetType.Private
        || val === SubnetType.Isolated;
}
function arraysEqual(as, bs) {
    if (as.length !== bs.length) {
        return false;
    }
    for (let i = 0; i < as.length; i++) {
        if (as[i] !== bs[i]) {
            return false;
        }
    }
    return true;
}
function findGroups(type, groups) {
    return groups.groups.filter(g => g.type === type);
}
function flatMap(xs, fn) {
    const ret = new Array();
    for (const x of xs) {
        ret.push(...fn(x));
    }
    return ret;
}
function collapse(xs) {
    if (xs.length > 0) {
        return xs;
    }
    return undefined;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidnBjcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInZwY3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx5Q0FBeUM7QUFFekMsZ0NBQW9DO0FBQ3BDLHdDQUFtQztBQUduQyxNQUFhLCtCQUErQjtJQUUxQyxZQUE2QixHQUFTO1FBQVQsUUFBRyxHQUFILEdBQUcsQ0FBTTtJQUN0QyxDQUFDO0lBRU0sS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUEyQjtRQUMvQyxNQUFNLE9BQU8sR0FBVyxJQUFJLENBQUMsT0FBUSxDQUFDO1FBQ3RDLE1BQU0sTUFBTSxHQUFXLElBQUksQ0FBQyxNQUFPLENBQUM7UUFFcEMsTUFBTSxHQUFHLEdBQUcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUVqRSxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRTVDLE9BQU8sTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVPLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBWSxFQUFFLElBQTJCO1FBQzdELDZFQUE2RTtRQUM3RSxNQUFNLE9BQU8sR0FBcUIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBRXRILGVBQUssQ0FBQyxtQkFBbUIsSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztRQUN4RCxN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QUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7WUFDekksZ0JBQWdCLEVBQUUsUUFBUSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDekgsa0JBQWtCLEVBQUUsUUFBUSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUN2SCwwQkFBMEIsRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztZQUN2SSxlQUFlLEVBQUUsUUFBUSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDdkgsaUJBQWlCLEVBQUUsUUFBUSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFD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QUksS0FBSyxJQUFJLENBQUMsQ0FBQztBQUNwRCxDQUFDO0FBRUQsU0FBUyxPQUFPLENBQU8sRUFBTyxFQUFFLEVBQWlCO0lBQy9DLE1BQU0sR0FBRyxHQUFHLElBQUksS0FBSyxFQUFLLENBQUM7SUFDM0IsS0FBSyxNQUFNLENBQUMsSUFBSSxFQUFFLEVBQUU7UUFDbEIsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3BCO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBRUQsU0FBUyxRQUFRLENBQUksRUFBTztJQUMxQixJQUFJLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQUUsT0FBTyxFQUFFLENBQUM7S0FBRTtJQUNqQyxPQUFPLFNBQVMsQ0FBQztBQUVuQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIEFXUyBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCB7IElTREssIE1vZGUgfSBmcm9tICcuLi9hcGknO1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi9sb2dnaW5nJztcbmltcG9ydCB7IENvbnRleHRQcm92aWRlclBsdWdpbiB9IGZyb20gJy4vcHJvdmlkZXInO1xuXG5leHBvcnQgY2xhc3MgVnBjTmV0d29ya0NvbnRleHRQcm92aWRlclBsdWdpbiBpbXBsZW1lbnRzIENvbnRleHRQcm92aWRlclBsdWdpbiB7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBhd3M6IElTREspIHtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRWYWx1ZShhcmdzOiBjeGFwaS5WcGNDb250ZXh0UXVlcnkpIHtcbiAgICBjb25zdCBhY2NvdW50OiBzdHJpbmcgPSBhcmdzLmFjY291bnQhO1xuICAgIGNvbnN0IHJlZ2lvbjogc3RyaW5nID0gYXJncy5yZWdpb24hO1xuXG4gICAgY29uc3QgZWMyID0gYXdhaXQgdGhpcy5hd3MuZWMyKGFjY291bnQsIHJlZ2lvbiwgTW9kZS5Gb3JSZWFkaW5nKTtcblxuICAgIGNvbnN0IHZwY0lkID0gYXdhaXQgdGhpcy5maW5kVnBjKGVjMiwgYXJncyk7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5yZWFkVnBjUHJvcHMoZWMyLCB2cGNJZCwgYXJncyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZpbmRWcGMoZWMyOiBBV1MuRUMyLCBhcmdzOiBjeGFwaS5WcGNDb250ZXh0UXVlcnkpOiBQcm9taXNlPEFXUy5FQzIuVnBjPiB7XG4gICAgLy8gQnVpbGQgcmVxdWVzdCBmaWx0ZXIgKG1hcCB7IE5hbWUgLT4gVmFsdWUgfSB0byBsaXN0IG9mIFt7IE5hbWUsIFZhbHVlcyB9XSlcbiAgICBjb25zdCBmaWx0ZXJzOiBBV1MuRUMyLkZpbHRlcltdID0gT2JqZWN0LmVudHJpZXMoYXJncy5maWx0ZXIpLm1hcCgoW3RhZywgdmFsdWVdKSA9PiAoeyBOYW1lOiB0YWcsIFZhbHVlczogW3ZhbHVlXSB9KSk7XG5cbiAgICBkZWJ1ZyhgTGlzdGluZyBWUENzIGluICR7YXJncy5hY2NvdW50fToke2FyZ3MucmVnaW9ufWApO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZWMyLmRlc2NyaWJlVnBjcyh7IEZpbHRlcnM6IGZpbHRlcnMgfSkucHJvbWlzZSgpO1xuXG4gICAgY29uc3QgdnBjcyA9IHJlc3BvbnNlLlZwY3MgfHwgW107XG4gICAgaWYgKHZwY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGFueSBWUENzIG1hdGNoaW5nICR7SlNPTi5zdHJpbmdpZnkoYXJncyl9YCk7XG4gICAgfVxuICAgIGlmICh2cGNzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRm91bmQgJHt2cGNzLmxlbmd0aH0gVlBDcyBtYXRjaGluZyAke0pTT04uc3RyaW5naWZ5KGFyZ3MpfTsgcGxlYXNlIG5hcnJvdyB0aGUgc2VhcmNoIGNyaXRlcmlhYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZwY3NbMF07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJlYWRWcGNQcm9wcyhlYzI6IEFXUy5FQzIsIHZwYzogQVdTLkVDMi5WcGMsIGFyZ3M6IGN4YXBpLlZwY0NvbnRleHRRdWVyeSk6IFByb21pc2U8Y3hhcGkuVnBjQ29udGV4dFJlc3BvbnNlPiB7XG4gICAgY29uc3QgdnBjSWQgPSB2cGMuVnBjSWQhO1xuXG4gICAgZGVidWcoYERlc2NyaWJpbmcgVlBDICR7dnBjSWR9YCk7XG5cbiAgICBjb25zdCBmaWx0ZXJzID0geyBGaWx0ZXJzOiBbeyBOYW1lOiAndnBjLWlkJywgVmFsdWVzOiBbdnBjSWRdIH1dIH07XG5cbiAgICBjb25zdCBzdWJuZXRzUmVzcG9uc2UgPSBhd2FpdCBlYzIuZGVzY3JpYmVTdWJuZXRzKGZpbHRlcnMpLnByb21pc2UoKTtcbiAgICBjb25zdCBsaXN0ZWRTdWJuZXRzID0gc3VibmV0c1Jlc3BvbnNlLlN1Ym5ldHMgfHwgW107XG5cbiAgICBjb25zdCByb3V0ZVRhYmxlc1Jlc3BvbnNlID0gYXdhaXQgZWMyLmRlc2NyaWJlUm91dGVUYWJsZXMoZmlsdGVycykucHJvbWlzZSgpO1xuICAgIGNvbnN0IHJvdXRlVGFibGVzID0gbmV3IFJvdXRlVGFibGVzKHJvdXRlVGFibGVzUmVzcG9uc2UuUm91dGVUYWJsZXMgfHwgW10pO1xuXG4gICAgLy8gTm93IGNvbWVzIG91ciBqb2IgdG8gc2VwYXJhdGUgdGhlc2Ugc3VibmV0cyBvdXQgaW50byBBWnMgYW5kIHN1Ym5ldCBncm91cHMgKFB1YmxpYywgUHJpdmF0ZSwgSXNvbGF0ZWQpXG4gICAgLy8gV2UgaGF2ZSB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXMgdG8gZ28gb246XG4gICAgLy8gLSBUeXBlIHRhZywgd2UgdGFnIHN1Ym5ldHMgd2l0aCB0aGVpciB0eXBlLiBJbiBhYnNlbmNlIG9mIHRoaXMgdGFnLCB3ZVxuICAgIC8vICAgZmFsbCBiYWNrIHRvIE1hcFB1YmxpY0lwT25MYXVuY2ggPT4gbXVzdCBiZSBhIFB1YmxpYyBzdWJuZXQsIGFueXRoaW5nXG4gICAgLy8gICBlbHNlIGlzIGNvbnNpZGVyZWQgUHJpYXRlLlxuICAgIC8vIC0gTmFtZSB0YWcsIHdlIHRhZyBzdWJuZXRzIHdpdGggdGhlaXIgc3VibmV0IGdyb3VwIG5hbWUuIEluIGFic2VuY2Ugb2YgdGhpcyB0YWcsXG4gICAgLy8gICB3ZSB1c2UgdGhlIHR5cGUgYXMgdGhlIG5hbWUuXG5cbiAgICBjb25zdCBhenMgPSBBcnJheS5mcm9tKG5ldyBTZXQ8c3RyaW5nPihsaXN0ZWRTdWJuZXRzLm1hcChzID0+IHMuQXZhaWxhYmlsaXR5Wm9uZSEpKSk7XG4gICAgYXpzLnNvcnQoKTtcblxuICAgIGNvbnN0IHN1Ym5ldHM6IFN1Ym5ldFtdID0gbGlzdGVkU3VibmV0cy5tYXAoc3VibmV0ID0+IHtcbiAgICAgIGxldCB0eXBlID0gZ2V0VGFnKCdhd3MtY2RrOnN1Ym5ldC10eXBlJywgc3VibmV0LlRhZ3MpO1xuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCAmJiBzdWJuZXQuTWFwUHVibGljSXBPbkxhdW5jaCkgeyB0eXBlID0gU3VibmV0VHlwZS5QdWJsaWM7IH1cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgJiYgcm91dGVUYWJsZXMuaGFzUm91dGVUb0lndyhzdWJuZXQuU3VibmV0SWQpKSB7IHR5cGUgPSBTdWJuZXRUeXBlLlB1YmxpYzsgfVxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkgeyB0eXBlID0gU3VibmV0VHlwZS5Qcml2YXRlOyB9XG5cbiAgICAgIGlmICghaXNWYWxpZFN1Ym5ldFR5cGUodHlwZSkpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBtYXgtbGluZS1sZW5ndGhcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdWJuZXQgJHtzdWJuZXQuU3VibmV0QXJufSBoYXMgaW52YWxpZCBzdWJuZXQgdHlwZSAke3R5cGV9IChtdXN0IGJlICR7U3VibmV0VHlwZS5QdWJsaWN9LCAke1N1Ym5ldFR5cGUuUHJpdmF0ZX0gb3IgJHtTdWJuZXRUeXBlLklzb2xhdGVkfSlgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmFtZSA9IGdldFRhZyhhcmdzLnN1Ym5ldEdyb3VwTmFtZVRhZyB8fCAnYXdzLWNkazpzdWJuZXQtbmFtZScsIHN1Ym5ldC5UYWdzKSB8fCB0eXBlO1xuICAgICAgY29uc3Qgcm91dGVUYWJsZUlkID0gcm91dGVUYWJsZXMucm91dGVUYWJsZUlkRm9yU3VibmV0SWQoc3VibmV0LlN1Ym5ldElkKTtcblxuICAgICAgaWYgKCFyb3V0ZVRhYmxlSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdWJuZXQgJHtzdWJuZXQuU3VibmV0QXJufSBkb2VzIG5vdCBoYXZlIGFuIGFzc29jaWF0ZWQgcm91dGUgdGFibGUgKGFuZCB0aGVyZSBpcyBubyBcIm1haW5cIiB0YWJsZSlgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXo6IHN1Ym5ldC5BdmFpbGFiaWxpdHlab25lISxcbiAgICAgICAgY2lkcjogc3VibmV0LkNpZHJCbG9jayEsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHN1Ym5ldElkOiBzdWJuZXQuU3VibmV0SWQhLFxuICAgICAgICByb3V0ZVRhYmxlSWQsXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgbGV0IGdyb3VwZWQ6IFN1Ym5ldEdyb3VwcztcbiAgICBsZXQgYXNzeW1ldHJpY1N1Ym5ldEdyb3VwczogY3hhcGkuVnBjU3VibmV0R3JvdXBbXSB8IHVuZGVmaW5lZDtcbiAgICBpZiAoYXJncy5yZXR1cm5Bc3ltbWV0cmljU3VibmV0cykge1xuICAgICAgZ3JvdXBlZCA9IHsgYXpzOiBbXSwgZ3JvdXBzOiBbXSB9O1xuICAgICAgYXNzeW1ldHJpY1N1Ym5ldEdyb3VwcyA9IGdyb3VwQXN5bW1ldHJpY1N1Ym5ldHMoc3VibmV0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwZWQgPSBncm91cFN1Ym5ldHMoc3VibmV0cyk7XG4gICAgICBhc3N5bWV0cmljU3VibmV0R3JvdXBzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIEZpbmQgYXR0YWNoZWQrYXZhaWxhYmxlIFZQTiBnYXRld2F5IGZvciB0aGlzIFZQQ1xuICAgIGNvbnN0IHZwbkdhdGV3YXlSZXNwb25zZSA9IGF3YWl0IGVjMi5kZXNjcmliZVZwbkdhdGV3YXlzKHtcbiAgICAgIEZpbHRlcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIE5hbWU6ICdhdHRhY2htZW50LnZwYy1pZCcsXG4gICAgICAgICAgVmFsdWVzOiBbdnBjSWRdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBOYW1lOiAnYXR0YWNobWVudC5zdGF0ZScsXG4gICAgICAgICAgVmFsdWVzOiBbJ2F0dGFjaGVkJ11cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIE5hbWU6ICdzdGF0ZScsXG4gICAgICAgICAgVmFsdWVzOiBbJ2F2YWlsYWJsZSddXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KS5wcm9taXNlKCk7XG4gICAgY29uc3QgdnBuR2F0ZXdheUlkID0gdnBuR2F0ZXdheVJlc3BvbnNlLlZwbkdhdGV3YXlzICYmIHZwbkdhdGV3YXlSZXNwb25zZS5WcG5HYXRld2F5cy5sZW5ndGggPT09IDFcbiAgICAgID8gdnBuR2F0ZXdheVJlc3BvbnNlLlZwbkdhdGV3YXlzWzBdLlZwbkdhdGV3YXlJZFxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdnBjSWQsXG4gICAgICB2cGNDaWRyQmxvY2s6IHZwYy5DaWRyQmxvY2shLFxuICAgICAgYXZhaWxhYmlsaXR5Wm9uZXM6IGdyb3VwZWQuYXpzLFxuICAgICAgaXNvbGF0ZWRTdWJuZXRJZHM6IGNvbGxhcHNlKGZsYXRNYXAoZmluZEdyb3VwcyhTdWJuZXRUeXBlLklzb2xhdGVkLCBncm91cGVkKSwgZ3JvdXAgPT4gZ3JvdXAuc3VibmV0cy5tYXAocyA9PiBzLnN1Ym5ldElkKSkpLFxuICAgICAgaXNvbGF0ZWRTdWJuZXROYW1lczogY29sbGFwc2UoZmxhdE1hcChmaW5kR3JvdXBzKFN1Ym5ldFR5cGUuSXNvbGF0ZWQsIGdyb3VwZWQpLCBncm91cCA9PiBncm91cC5uYW1lID8gW2dyb3VwLm5hbWVdIDogW10pKSxcbiAgICAgIGlzb2xhdGVkU3VibmV0Um91dGVUYWJsZUlkczogY29sbGFwc2UoZmxhdE1hcChmaW5kR3JvdXBzKFN1Ym5ldFR5cGUuSXNvbGF0ZWQsIGdyb3VwZWQpLCBncm91cCA9PiBncm91cC5zdWJuZXRzLm1hcChzID0+IHMucm91dGVUYWJsZUlkKSkpLFxuICAgICAgcHJpdmF0ZVN1Ym5ldElkczogY29sbGFwc2UoZmxhdE1hcChmaW5kR3JvdXBzKFN1Ym5ldFR5cGUuUHJpdmF0ZSwgZ3JvdXBlZCksIGdyb3VwID0+IGdyb3VwLnN1Ym5ldHMubWFwKHMgPT4gcy5zdWJuZXRJZCkpKSxcbiAgICAgIHByaXZhdGVTdWJuZXROYW1lczogY29sbGFwc2UoZmxhdE1hcChmaW5kR3JvdXBzKFN1Ym5ldFR5cGUuUHJpdmF0ZSwgZ3JvdXBlZCksIGdyb3VwID0+IGdyb3VwLm5hbWUgPyBbZ3JvdXAubmFtZV0gOiBbXSkpLFxuICAgICAgcHJpdmF0ZVN1Ym5ldFJvdXRlVGFibGVJZHM6IGNvbGxhcHNlKGZsYXRNYXAoZmluZEdyb3VwcyhTdWJuZXRUeXBlLlByaXZhdGUsIGdyb3VwZWQpLCBncm91cCA9PiBncm91cC5zdWJuZXRzLm1hcChzID0+IHMucm91dGVUYWJsZUlkKSkpLFxuICAgICAgcHVibGljU3VibmV0SWRzOiBjb2xsYXBzZShmbGF0TWFwKGZpbmRHcm91cHMoU3VibmV0VHlwZS5QdWJsaWMsIGdyb3VwZWQpLCBncm91cCA9PiBncm91cC5zdWJuZXRzLm1hcChzID0+IHMuc3VibmV0SWQpKSksXG4gICAgICBwdWJsaWNTdWJuZXROYW1lczogY29sbGFwc2UoZmxhdE1hcChmaW5kR3JvdXBzKFN1Ym5ldFR5cGUuUHVibGljLCBncm91cGVkKSwgZ3JvdXAgPT4gZ3JvdXAubmFtZSA/IFtncm91cC5uYW1lXSA6IFtdKSksXG4gICAgICBwdWJsaWNTdWJuZXRSb3V0ZVRhYmxlSWRzOiBjb2xsYXBzZShmbGF0TWFwKGZpbmRHcm91cHMoU3VibmV0VHlwZS5QdWJsaWMsIGdyb3VwZWQpLCBncm91cCA9PiBncm91cC5zdWJuZXRzLm1hcChzID0+IHMucm91dGVUYWJsZUlkKSkpLFxuICAgICAgdnBuR2F0ZXdheUlkLFxuICAgICAgc3VibmV0R3JvdXBzOiBhc3N5bWV0cmljU3VibmV0R3JvdXBzLFxuICAgIH07XG4gIH1cbn1cblxuY2xhc3MgUm91dGVUYWJsZXMge1xuICBwdWJsaWMgcmVhZG9ubHkgbWFpblJvdXRlVGFibGU/OiBBV1MuRUMyLlJvdXRlVGFibGU7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSB0YWJsZXM6IEFXUy5FQzIuUm91dGVUYWJsZVtdKSB7XG4gICAgdGhpcy5tYWluUm91dGVUYWJsZSA9IHRoaXMudGFibGVzLmZpbmQodGFibGUgPT4gISF0YWJsZS5Bc3NvY2lhdGlvbnMgJiYgdGFibGUuQXNzb2NpYXRpb25zLnNvbWUoYXNzb2MgPT4gISFhc3NvYy5NYWluKSk7XG4gIH1cblxuICBwdWJsaWMgcm91dGVUYWJsZUlkRm9yU3VibmV0SWQoc3VibmV0SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnRhYmxlRm9yU3VibmV0KHN1Ym5ldElkKTtcbiAgICByZXR1cm4gKHRhYmxlICYmIHRhYmxlLlJvdXRlVGFibGVJZCkgfHwgKHRoaXMubWFpblJvdXRlVGFibGUgJiYgdGhpcy5tYWluUm91dGVUYWJsZS5Sb3V0ZVRhYmxlSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGdpdmVuIHN1Ym5ldCBoYXMgYSByb3V0ZSB0byBhbiBJR1dcbiAgICovXG4gIHB1YmxpYyBoYXNSb3V0ZVRvSWd3KHN1Ym5ldElkOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMudGFibGVGb3JTdWJuZXQoc3VibmV0SWQpO1xuXG4gICAgcmV0dXJuICEhdGFibGUgJiYgISF0YWJsZS5Sb3V0ZXMgJiYgdGFibGUuUm91dGVzLnNvbWUocm91dGUgPT4gISFyb3V0ZS5HYXRld2F5SWQgJiYgcm91dGUuR2F0ZXdheUlkLnN0YXJ0c1dpdGgoJ2lndy0nKSk7XG4gIH1cblxuICBwdWJsaWMgdGFibGVGb3JTdWJuZXQoc3VibmV0SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlcy5maW5kKHRhYmxlID0+ICEhdGFibGUuQXNzb2NpYXRpb25zICYmIHRhYmxlLkFzc29jaWF0aW9ucy5zb21lKGFzc29jID0+IGFzc29jLlN1Ym5ldElkID09PSBzdWJuZXRJZCkpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSB2YWx1ZSBvZiBhIHRhZyBmcm9tIGEgc2V0IG9mIHRhZ3NcbiAqL1xuZnVuY3Rpb24gZ2V0VGFnKG5hbWU6IHN0cmluZywgdGFncz86IEFXUy5FQzIuVGFnW10pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBmb3IgKGNvbnN0IHRhZyBvZiB0YWdzIHx8IFtdKSB7XG4gICAgaWYgKHRhZy5LZXkgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiB0YWcuVmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogR3JvdXAgc3VibmV0cyBvZiB0aGUgc2FtZSB0eXBlIHRvZ2V0aGVyLCBhbmQgb3JkZXIgYnkgQVpcbiAqL1xuZnVuY3Rpb24gZ3JvdXBTdWJuZXRzKHN1Ym5ldHM6IFN1Ym5ldFtdKTogU3VibmV0R3JvdXBzIHtcbiAgY29uc3QgZ3JvdXBpbmc6IHtba2V5OiBzdHJpbmddOiBTdWJuZXRbXX0gPSB7fTtcbiAgZm9yIChjb25zdCBzdWJuZXQgb2Ygc3VibmV0cykge1xuICAgIGNvbnN0IGtleSA9IFtzdWJuZXQudHlwZSwgc3VibmV0Lm5hbWVdLnRvU3RyaW5nKCk7XG4gICAgaWYgKCEoa2V5IGluIGdyb3VwaW5nKSkgeyBncm91cGluZ1trZXldID0gW107IH1cbiAgICBncm91cGluZ1trZXldLnB1c2goc3VibmV0KTtcbiAgfVxuXG4gIGNvbnN0IGdyb3VwcyA9IE9iamVjdC52YWx1ZXMoZ3JvdXBpbmcpLm1hcChzbnMgPT4ge1xuICAgIHNucy5zb3J0KChhOiBTdWJuZXQsIGI6IFN1Ym5ldCkgPT4gYS5hei5sb2NhbGVDb21wYXJlKGIuYXopKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogc25zWzBdLnR5cGUsXG4gICAgICBuYW1lOiBzbnNbMF0ubmFtZSxcbiAgICAgIHN1Ym5ldHM6IHNucyxcbiAgICB9O1xuICB9KTtcblxuICBjb25zdCBhenMgPSBncm91cHNbMF0uc3VibmV0cy5tYXAocyA9PiBzLmF6KTtcblxuICBmb3IgKGNvbnN0IGdyb3VwIG9mIGdyb3Vwcykge1xuICAgIGNvbnN0IGdyb3VwQVpzID0gZ3JvdXAuc3VibmV0cy5tYXAocyA9PiBzLmF6KTtcbiAgICBpZiAoIWFycmF5c0VxdWFsKGdyb3VwQVpzLCBhenMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhbGwgc3VibmV0cyBpbiBWUEMgaGF2ZSB0aGUgc2FtZSBBWnM6ICR7Z3JvdXBBWnN9IHZzICR7YXpzfWApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGF6cywgZ3JvdXBzIH07XG59XG5cbmZ1bmN0aW9uIGdyb3VwQXN5bW1ldHJpY1N1Ym5ldHMoc3VibmV0czogU3VibmV0W10pOiBjeGFwaS5WcGNTdWJuZXRHcm91cFtdIHtcbiAgY29uc3QgZ3JvdXBpbmc6IHsgW2tleTogc3RyaW5nXTogU3VibmV0W10gfSA9IHt9O1xuICBmb3IgKGNvbnN0IHN1Ym5ldCBvZiBzdWJuZXRzKSB7XG4gICAgY29uc3Qga2V5ID0gW3N1Ym5ldC50eXBlLCBzdWJuZXQubmFtZV0udG9TdHJpbmcoKTtcbiAgICBpZiAoIShrZXkgaW4gZ3JvdXBpbmcpKSB7XG4gICAgICBncm91cGluZ1trZXldID0gW107XG4gICAgfVxuICAgIGdyb3VwaW5nW2tleV0ucHVzaChzdWJuZXQpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZ3JvdXBpbmcpLm1hcChzdWJuZXRBcnJheSA9PiB7XG4gICAgc3VibmV0QXJyYXkuc29ydCgoc3VibmV0MTogU3VibmV0LCBzdWJuZXQyOiBTdWJuZXQpID0+IHN1Ym5ldDEuYXoubG9jYWxlQ29tcGFyZShzdWJuZXQyLmF6KSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogc3VibmV0QXJyYXlbMF0ubmFtZSxcbiAgICAgIHR5cGU6IHN1Ym5ldFR5cGVUb1ZwY1N1Ym5ldFR5cGUoc3VibmV0QXJyYXlbMF0udHlwZSksXG4gICAgICBzdWJuZXRzOiBzdWJuZXRBcnJheS5tYXAoc3VibmV0ID0+ICh7XG4gICAgICAgIHN1Ym5ldElkOiBzdWJuZXQuc3VibmV0SWQsXG4gICAgICAgIGNpZHI6IHN1Ym5ldC5jaWRyLFxuICAgICAgICBhdmFpbGFiaWxpdHlab25lOiBzdWJuZXQuYXosXG4gICAgICAgIHJvdXRlVGFibGVJZDogc3VibmV0LnJvdXRlVGFibGVJZCxcbiAgICAgIH0pKSxcbiAgICB9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc3VibmV0VHlwZVRvVnBjU3VibmV0VHlwZSh0eXBlOiBTdWJuZXRUeXBlKTogY3hhcGkuVnBjU3VibmV0R3JvdXBUeXBlIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBTdWJuZXRUeXBlLklzb2xhdGVkOiByZXR1cm4gY3hhcGkuVnBjU3VibmV0R3JvdXBUeXBlLklTT0xBVEVEO1xuICAgIGNhc2UgU3VibmV0VHlwZS5Qcml2YXRlOiByZXR1cm4gY3hhcGkuVnBjU3VibmV0R3JvdXBUeXBlLlBSSVZBVEU7XG4gICAgY2FzZSBTdWJuZXRUeXBlLlB1YmxpYzogcmV0dXJuIGN4YXBpLlZwY1N1Ym5ldEdyb3VwVHlwZS5QVUJMSUM7XG4gIH1cbn1cblxuZW51bSBTdWJuZXRUeXBlIHtcbiAgUHVibGljID0gJ1B1YmxpYycsXG4gIFByaXZhdGUgPSAnUHJpdmF0ZScsXG4gIElzb2xhdGVkID0gJ0lzb2xhdGVkJ1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkU3VibmV0VHlwZSh2YWw6IHN0cmluZyk6IHZhbCBpcyBTdWJuZXRUeXBlIHtcbiAgcmV0dXJuIHZhbCA9PT0gU3VibmV0VHlwZS5QdWJsaWNcbiAgICB8fCB2YWwgPT09IFN1Ym5ldFR5cGUuUHJpdmF0ZVxuICAgIHx8IHZhbCA9PT0gU3VibmV0VHlwZS5Jc29sYXRlZDtcbn1cblxuaW50ZXJmYWNlIFN1Ym5ldCB7XG4gIGF6OiBzdHJpbmc7XG4gIGNpZHI6IHN0cmluZztcbiAgdHlwZTogU3VibmV0VHlwZTtcbiAgbmFtZTogc3RyaW5nO1xuICByb3V0ZVRhYmxlSWQ6IHN0cmluZztcbiAgc3VibmV0SWQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFN1Ym5ldEdyb3VwIHtcbiAgdHlwZTogU3VibmV0VHlwZTtcbiAgbmFtZTogc3RyaW5nO1xuICBzdWJuZXRzOiBTdWJuZXRbXTtcbn1cblxuaW50ZXJmYWNlIFN1Ym5ldEdyb3VwcyB7XG4gIGF6czogc3RyaW5nW107XG4gIGdyb3VwczogU3VibmV0R3JvdXBbXTtcbn1cblxuZnVuY3Rpb24gYXJyYXlzRXF1YWwoYXM6IHN0cmluZ1tdLCBiczogc3RyaW5nW10pOiBib29sZWFuIHtcbiAgaWYgKGFzLmxlbmd0aCAhPT0gYnMubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXNbaV0gIT09IGJzW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZpbmRHcm91cHModHlwZTogU3VibmV0VHlwZSwgZ3JvdXBzOiBTdWJuZXRHcm91cHMpOiBTdWJuZXRHcm91cFtdIHtcbiAgcmV0dXJuIGdyb3Vwcy5ncm91cHMuZmlsdGVyKGcgPT4gZy50eXBlID09PSB0eXBlKTtcbn1cblxuZnVuY3Rpb24gZmxhdE1hcDxULCBVPih4czogVFtdLCBmbjogKHg6IFQpID0+IFVbXSk6IFVbXSB7XG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheTxVPigpO1xuICBmb3IgKGNvbnN0IHggb2YgeHMpIHtcbiAgICByZXQucHVzaCguLi5mbih4KSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gY29sbGFwc2U8VD4oeHM6IFRbXSk6IFRbXSB8IHVuZGVmaW5lZCB7XG4gIGlmICh4cy5sZW5ndGggPiAwKSB7IHJldHVybiB4czsgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xuXG59XG4iXX0=