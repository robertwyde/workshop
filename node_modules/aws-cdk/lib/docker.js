"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const logging_1 = require("./logging");
const os_1 = require("./os");
/**
 * Build and upload a Docker image
 *
 * Permanently identifying images is a bit of a bust. Newer Docker version use
 * a digest (sha256:xxxx) as an image identifier, which is pretty good to avoid
 * spurious rebuilds. However, this digest is calculated over a manifest that
 * includes metadata that is liable to change. For example, as soon as we
 * push the Docker image to a repository, the digest changes. This makes the
 * digest worthless to determe whether we already pushed an image, for example.
 *
 * As a workaround, we calculate our own digest over parts of the manifest that
 * are unlikely to change, and tag based on that.
 *
 * When running in CI, we pull the latest image first and use it as cache for
 * the build. Generally pulling will be faster than building, especially for
 * Dockerfiles with lots of OS/code packages installation or changes only in
 * the bottom layers. When running locally chances are that we already have
 * layers cache available.
 *
 * CI is detected by the presence of the `CI` environment variable or
 * the `--ci` command line option.
 */
async function prepareContainerAsset(assemblyDir, asset, toolkitInfo, reuse, ci) {
    var _a, _b;
    // following 1.21.0, image asset location (repositoryName and imageTag) is fully determined by the
    // app, and therefore there is no need to wire the image name through a cloudformation parameter.
    if (!asset.imageNameParameter) {
        await prepareContainerAssetNew(assemblyDir, asset, toolkitInfo);
        return [];
    }
    if (reuse) {
        return [
            { ParameterKey: asset.imageNameParameter, UsePreviousValue: true },
        ];
    }
    const contextPath = path.isAbsolute(asset.path) ? asset.path : path.join(assemblyDir, asset.path);
    logging_1.debug(' ðŸ‘‘  Preparing Docker image asset:', contextPath);
    try {
        const repositoryName = (_a = asset.repositoryName, (_a !== null && _a !== void 0 ? _a : 'cdk/' + asset.id.replace(/[:/]/g, '-').toLowerCase()));
        const ecr = await toolkitInfo.prepareEcrRepository(repositoryName);
        const imageTag = (_b = asset.imageTag, (_b !== null && _b !== void 0 ? _b : 'latest'));
        const latest = `${ecr.repositoryUri}:${imageTag}`;
        let loggedIn = false;
        // In CI we try to pull latest first
        if (ci) {
            await dockerLogin(toolkitInfo);
            loggedIn = true;
            try {
                await os_1.shell(['docker', 'pull', latest]);
            }
            catch (e) {
                logging_1.debug('Failed to pull latest image from ECR repository');
            }
        }
        const buildArgs = [].concat(...Object.entries(asset.buildArgs || {}).map(([k, v]) => ['--build-arg', `${k}=${v}`]));
        const baseCommand = [
            'docker', 'build',
            ...buildArgs,
            '--tag', latest,
            contextPath
        ];
        if (asset.target) {
            baseCommand.push('--target', asset.target);
        }
        if (asset.file) {
            // remember we assume the file is relative (we validate this in the asset constructor)
            baseCommand.push('--file', path.join(contextPath, asset.file));
        }
        const command = ci
            ? [...baseCommand, '--cache-from', latest] // This does not fail if latest is not available
            : baseCommand;
        await os_1.shell(command);
        // Login and push
        if (!loggedIn) { // We could be already logged in if in CI
            await dockerLogin(toolkitInfo);
            loggedIn = true;
        }
        // There's no way to make this quiet, so we can't use a PleaseHold. Print a header message.
        logging_1.print(` âŒ› Pushing Docker image for ${contextPath}; this may take a while.`);
        await os_1.shell(['docker', 'push', latest]);
        logging_1.debug(` ðŸ‘‘  Docker image for ${contextPath} pushed.`);
        // Get the (single) repo-digest for latest, which'll be <ecr.repositoryUrl>@sha256:<repoImageSha256>
        const repoDigests = (await os_1.shell(['docker', 'image', 'inspect', latest, '--format', '{{range .RepoDigests}}{{.}}|{{end}}'])).trim();
        const requiredPrefix = `${ecr.repositoryUri}@sha256:`;
        const repoDigest = repoDigests.split('|').find(digest => digest.startsWith(requiredPrefix));
        if (!repoDigest) {
            throw new Error(`Unable to identify repository digest (none starts with ${requiredPrefix}) in:\n${repoDigests}`);
        }
        return [
            { ParameterKey: asset.imageNameParameter, ParameterValue: repoDigest.replace(ecr.repositoryUri, repositoryName) },
        ];
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            // tslint:disable-next-line:max-line-length
            throw new Error('Error building Docker image asset; you need to have Docker installed in order to be able to build image assets. Please install Docker and try again.');
        }
        throw e;
    }
}
exports.prepareContainerAsset = prepareContainerAsset;
/**
 * Build and upload a Docker image
 */
async function prepareContainerAssetNew(assemblyDir, asset, toolkitInfo) {
    if (asset.imageNameParameter || !asset.repositoryName || !asset.imageTag) {
        throw new Error(`invalid docker image asset configuration. "repositoryName" and "imageTag" are required and "imageNameParameter" is not allowed`);
    }
    const contextPath = path.isAbsolute(asset.path) ? asset.path : path.join(assemblyDir, asset.path);
    logging_1.debug(' ðŸ‘‘  Preparing Docker image asset:', contextPath);
    const ecr = await toolkitInfo.prepareEcrRepository(asset.repositoryName);
    // if both repo name and image tag are explicitly defined, we assume the
    // image is immutable and can skip build & push.
    logging_1.debug(`${asset.repositoryName}:${asset.imageTag}: checking if image already exists`);
    if (await toolkitInfo.checkEcrImage(asset.repositoryName, asset.imageTag)) {
        logging_1.print(`${asset.repositoryName}:${asset.imageTag}: image already exists, skipping build and push`);
        return;
    }
    // we use "latest" for image tag for backwards compatibility with pre-1.21.0 apps.
    const fullImageName = `${ecr.repositoryUri}:${asset.imageTag}`;
    // render "docker build" command
    const buildCommand = ['docker', 'build'];
    buildCommand.push('--tag', fullImageName);
    if (asset.target) {
        buildCommand.push('--target', asset.target);
    }
    if (asset.file) {
        // remember we assume the file is relative (we validate this in the asset constructor)
        buildCommand.push('--file', path.join(contextPath, asset.file));
    }
    for (const [key, value] of Object.entries(asset.buildArgs || {})) {
        buildCommand.push(`--build-arg`, `${key}=${value}`);
    }
    buildCommand.push(contextPath);
    try {
        await os_1.shell(buildCommand);
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            throw new Error('Unable to execute "docker" in order to build a container asset. Please install "docker" and try again.');
        }
        throw e;
    }
    // login to ECR
    await dockerLogin(toolkitInfo);
    // There's no way to make this quiet, so we can't use a PleaseHold. Print a header message.
    logging_1.print(` âŒ› Pushing Docker image for ${contextPath}; this may take a while.`);
    await os_1.shell(['docker', 'push', fullImageName]);
    logging_1.debug(` ðŸ‘‘  Docker image for ${contextPath} pushed.`);
}
exports.prepareContainerAssetNew = prepareContainerAssetNew;
/**
 * Get credentials from ECR and run docker login
 */
async function dockerLogin(toolkitInfo) {
    const credentials = await toolkitInfo.getEcrCredentials();
    await os_1.shell(['docker', 'login',
        '--username', credentials.username,
        '--password', credentials.password,
        credentials.endpoint]);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9ja2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZG9ja2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsNkJBQTZCO0FBRTdCLHVDQUF5QztBQUN6Qyw2QkFBNkI7QUFFN0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCRztBQUNJLEtBQUssVUFBVSxxQkFBcUIsQ0FBQyxXQUFtQixFQUNuQixLQUF1QyxFQUN2QyxXQUF3QixFQUN4QixLQUFjLEVBQ2QsRUFBWTs7SUFFdEQsa0dBQWtHO0lBQ2xHLGlHQUFpRztJQUNqRyxJQUFJLENBQUMsS0FBSyxDQUFDLGtCQUFrQixFQUFFO1FBQzdCLE1BQU0sd0JBQXdCLENBQUMsV0FBVyxFQUFFLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQztRQUNoRSxPQUFPLEVBQUcsQ0FBQztLQUNaO0lBRUQsSUFBSSxLQUFLLEVBQUU7UUFDVCxPQUFPO1lBQ0wsRUFBRSxZQUFZLEVBQUUsS0FBSyxDQUFDLGtCQUFrQixFQUFFLGdCQUFnQixFQUFFLElBQUksRUFBRTtTQUNuRSxDQUFDO0tBQ0g7SUFFRCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRWxHLGVBQUssQ0FBQyxvQ0FBb0MsRUFBRSxXQUFXLENBQUMsQ0FBQztJQUV6RCxJQUFJO1FBQ0YsTUFBTSxjQUFjLFNBQUcsS0FBSyxDQUFDLGNBQWMsdUNBQUksTUFBTSxHQUFHLEtBQUssQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBQSxDQUFDO1FBQ3JHLE1BQU0sR0FBRyxHQUFHLE1BQU0sV0FBVyxDQUFDLG9CQUFvQixDQUFDLGNBQWMsQ0FB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LENBQUMsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO1lBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsd0dBQXdHLENBQUMsQ0FBQztTQUMzSDtRQUNELE1BQU0sQ0FBQyxDQUFDO0tBQ1Q7SUFFRCxlQUFlO0lBQ2YsTUFBTSxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7SUFFL0IsMkZBQTJGO0lBQzNGLGVBQUssQ0FBQywrQkFBK0IsV0FBVywwQkFBMEIsQ0FBQyxDQUFDO0lBQzVFLE1BQU0sVUFBSyxDQUFDLENBQUMsUUFBUSxFQUFFLE1BQU0sRUFBRSxhQUFhLENBQUMsQ0FBQyxDQUFDO0lBQy9DLGVBQUssQ0FBQyx5QkFBeUIsV0FBVyxVQUFVLENBQUMsQ0FBQztBQUN4RCxDQUFDO0FBN0RELDREQTZEQztBQUVEOztHQUVHO0FBQ0gsS0FBSyxVQUFVLFdBQVcsQ0FBQyxXQUF3QjtJQUNqRCxNQUFNLFdBQVcsR0FBRyxNQUFNLFdBQVcsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0lBQzFELE1BQU0sVUFBSyxDQUFDLENBQUMsUUFBUSxFQUFFLE9BQU87UUFDOUIsWUFBWSxFQUFFLFdBQVcsQ0FBQyxRQUFRO1FBQ2xDLFlBQVksRUFBRSxXQUFXLENBQUMsUUFBUTtRQUNsQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUN6QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29udGFpbmVySW1hZ2VBc3NldE1ldGFkYXRhRW50cnkgfSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHsgQ2xvdWRGb3JtYXRpb24gfSBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBUb29sa2l0SW5mbyB9IGZyb20gJy4vYXBpL3Rvb2xraXQtaW5mbyc7XG5pbXBvcnQgeyBkZWJ1ZywgcHJpbnQgfSBmcm9tICcuL2xvZ2dpbmcnO1xuaW1wb3J0IHsgc2hlbGwgfSBmcm9tICcuL29zJztcblxuLyoqXG4gKiBCdWlsZCBhbmQgdXBsb2FkIGEgRG9ja2VyIGltYWdlXG4gKlxuICogUGVybWFuZW50bHkgaWRlbnRpZnlpbmcgaW1hZ2VzIGlzIGEgYml0IG9mIGEgYnVzdC4gTmV3ZXIgRG9ja2VyIHZlcnNpb24gdXNlXG4gKiBhIGRpZ2VzdCAoc2hhMjU2Onh4eHgpIGFzIGFuIGltYWdlIGlkZW50aWZpZXIsIHdoaWNoIGlzIHByZXR0eSBnb29kIHRvIGF2b2lkXG4gKiBzcHVyaW91cyByZWJ1aWxkcy4gSG93ZXZlciwgdGhpcyBkaWdlc3QgaXMgY2FsY3VsYXRlZCBvdmVyIGEgbWFuaWZlc3QgdGhhdFxuICogaW5jbHVkZXMgbWV0YWRhdGEgdGhhdCBpcyBsaWFibGUgdG8gY2hhbmdlLiBGb3IgZXhhbXBsZSwgYXMgc29vbiBhcyB3ZVxuICogcHVzaCB0aGUgRG9ja2VyIGltYWdlIHRvIGEgcmVwb3NpdG9yeSwgdGhlIGRpZ2VzdCBjaGFuZ2VzLiBUaGlzIG1ha2VzIHRoZVxuICogZGlnZXN0IHdvcnRobGVzcyB0byBkZXRlcm1lIHdoZXRoZXIgd2UgYWxyZWFkeSBwdXNoZWQgYW4gaW1hZ2UsIGZvciBleGFtcGxlLlxuICpcbiAqIEFzIGEgd29ya2Fyb3VuZCwgd2UgY2FsY3VsYXRlIG91ciBvd24gZGlnZXN0IG92ZXIgcGFydHMgb2YgdGhlIG1hbmlmZXN0IHRoYXRcbiAqIGFyZSB1bmxpa2VseSB0byBjaGFuZ2UsIGFuZCB0YWcgYmFzZWQgb24gdGhhdC5cbiAqXG4gKiBXaGVuIHJ1bm5pbmcgaW4gQ0ksIHdlIHB1bGwgdGhlIGxhdGVzdCBpbWFnZSBmaXJzdCBhbmQgdXNlIGl0IGFzIGNhY2hlIGZvclxuICogdGhlIGJ1aWxkLiBHZW5lcmFsbHkgcHVsbGluZyB3aWxsIGJlIGZhc3RlciB0aGFuIGJ1aWxkaW5nLCBlc3BlY2lhbGx5IGZvclxuICogRG9ja2VyZmlsZXMgd2l0aCBsb3RzIG9mIE9TL2NvZGUgcGFja2FnZXMgaW5zdGFsbGF0aW9uIG9yIGNoYW5nZXMgb25seSBpblxuICogdGhlIGJvdHRvbSBsYXllcnMuIFdoZW4gcnVubmluZyBsb2NhbGx5IGNoYW5jZXMgYXJlIHRoYXQgd2UgYWxyZWFkeSBoYXZlXG4gKiBsYXllcnMgY2FjaGUgYXZhaWxhYmxlLlxuICpcbiAqIENJIGlzIGRldGVjdGVkIGJ5IHRoZSBwcmVzZW5jZSBvZiB0aGUgYENJYCBlbnZpcm9ubWVudCB2YXJpYWJsZSBvclxuICogdGhlIGAtLWNpYCBjb21tYW5kIGxpbmUgb3B0aW9uLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlcGFyZUNvbnRhaW5lckFzc2V0KGFzc2VtYmx5RGlyOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2V0OiBDb250YWluZXJJbWFnZUFzc2V0TWV0YWRhdGFFbnRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbGtpdEluZm86IFRvb2xraXRJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXVzZTogYm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2k/OiBib29sZWFuKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvbi5QYXJhbWV0ZXJbXT4ge1xuXG4gIC8vIGZvbGxvd2luZyAxLjIxLjAsIGltYWdlIGFzc2V0IGxvY2F0aW9uIChyZXBvc2l0b3J5TmFtZSBhbmQgaW1hZ2VUYWcpIGlzIGZ1bGx5IGRldGVybWluZWQgYnkgdGhlXG4gIC8vIGFwcCwgYW5kIHRoZXJlZm9yZSB0aGVyZSBpcyBubyBuZWVkIHRvIHdpcmUgdGhlIGltYWdlIG5hbWUgdGhyb3VnaCBhIGNsb3VkZm9ybWF0aW9uIHBhcmFtZXRlci5cbiAgaWYgKCFhc3NldC5pbWFnZU5hbWVQYXJhbWV0ZXIpIHtcbiAgICBhd2FpdCBwcmVwYXJlQ29udGFpbmVyQXNzZXROZXcoYXNzZW1ibHlEaXIsIGFzc2V0LCB0b29sa2l0SW5mbyk7XG4gICAgcmV0dXJuIFsgXTtcbiAgfVxuXG4gIGlmIChyZXVzZSkge1xuICAgIHJldHVybiBbXG4gICAgICB7IFBhcmFtZXRlcktleTogYXNzZXQuaW1hZ2VOYW1lUGFyYW1ldGVyLCBVc2VQcmV2aW91c1ZhbHVlOiB0cnVlIH0sXG4gICAgXTtcbiAgfVxuXG4gIGNvbnN0IGNvbnRleHRQYXRoID0gcGF0aC5pc0Fic29sdXRlKGFzc2V0LnBhdGgpID8gYXNzZXQucGF0aCA6IHBhdGguam9pbihhc3NlbWJseURpciwgYXNzZXQucGF0aCk7XG5cbiAgZGVidWcoJyDwn5GRICBQcmVwYXJpbmcgRG9ja2VyIGltYWdlIGFzc2V0OicsIGNvbnRleHRQYXRoKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHJlcG9zaXRvcnlOYW1lID0gYXNzZXQucmVwb3NpdG9yeU5hbWUgPz8gJ2Nkay8nICsgYXNzZXQuaWQucmVwbGFjZSgvWzovXS9nLCAnLScpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgZWNyID0gYXdhaXQgdG9vbGtpdEluZm8ucHJlcGFyZUVjclJlcG9zaXRvcnkocmVwb3NpdG9yeU5hbWUpO1xuICAgIGNvbnN0IGltYWdlVGFnID0gYXNzZXQuaW1hZ2VUYWcgPz8gJ2xhdGVzdCc7XG4gICAgY29uc3QgbGF0ZXN0ID0gYCR7ZWNyLnJlcG9zaXRvcnlVcml9OiR7aW1hZ2VUYWd9YDtcblxuICAgIGxldCBsb2dnZWRJbiA9IGZhbHNlO1xuXG4gICAgLy8gSW4gQ0kgd2UgdHJ5IHRvIHB1bGwgbGF0ZXN0IGZpcnN0XG4gICAgaWYgKGNpKSB7XG4gICAgICBhd2FpdCBkb2NrZXJMb2dpbih0b29sa2l0SW5mbyk7XG4gICAgICBsb2dnZWRJbiA9IHRydWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHNoZWxsKFsnZG9ja2VyJywgJ3B1bGwnLCBsYXRlc3RdKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVidWcoJ0ZhaWxlZCB0byBwdWxsIGxhdGVzdCBpbWFnZSBmcm9tIEVDUiByZXBvc2l0b3J5Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYnVpbGRBcmdzID0gKFtdIGFzIHN0cmluZ1tdKS5jb25jYXQoLi4uT2JqZWN0LmVudHJpZXMoYXNzZXQuYnVpbGRBcmdzIHx8IHt9KS5tYXAoKFtrLCB2XSkgPT4gWyctLWJ1aWxkLWFyZycsIGAke2t9PSR7dn1gXSkpO1xuXG4gICAgY29uc3QgYmFzZUNvbW1hbmQgPSBbXG4gICAgICAnZG9ja2VyJywgJ2J1aWxkJyxcbiAgICAgIC4uLmJ1aWxkQXJncyxcbiAgICAgICctLXRhZycsIGxhdGVzdCxcbiAgICAgIGNvbnRleHRQYXRoXG4gICAgXTtcblxuICAgIGlmIChhc3NldC50YXJnZXQpIHtcbiAgICAgIGJhc2VDb21tYW5kLnB1c2goJy0tdGFyZ2V0JywgYXNzZXQudGFyZ2V0KTtcbiAgICB9XG5cbiAgICBpZiAoYXNzZXQuZmlsZSkge1xuICAgICAgLy8gcmVtZW1iZXIgd2UgYXNzdW1lIHRoZSBmaWxlIGlzIHJlbGF0aXZlICh3ZSB2YWxpZGF0ZSB0aGlzIGluIHRoZSBhc3NldCBjb25zdHJ1Y3RvcilcbiAgICAgIGJhc2VDb21tYW5kLnB1c2goJy0tZmlsZScsIHBhdGguam9pbihjb250ZXh0UGF0aCwgYXNzZXQuZmlsZSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbW1hbmQgPSBjaVxuICAgICAgPyBbLi4uYmFzZUNvbW1hbmQsICctLWNhY2hlLWZyb20nLCBsYXRlc3RdIC8vIFRoaXMgZG9lcyBub3QgZmFpbCBpZiBsYXRlc3QgaXMgbm90IGF2YWlsYWJsZVxuICAgICAgOiBiYXNlQ29tbWFuZDtcbiAgICBhd2FpdCBzaGVsbChjb21tYW5kKTtcblxuICAgIC8vIExvZ2luIGFuZCBwdXNoXG4gICAgaWYgKCFsb2dnZWRJbikgeyAvLyBXZSBjb3VsZCBiZSBhbHJlYWR5IGxvZ2dlZCBpbiBpZiBpbiBDSVxuICAgICAgYXdhaXQgZG9ja2VyTG9naW4odG9vbGtpdEluZm8pO1xuICAgICAgbG9nZ2VkSW4gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFRoZXJlJ3Mgbm8gd2F5IHRvIG1ha2UgdGhpcyBxdWlldCwgc28gd2UgY2FuJ3QgdXNlIGEgUGxlYXNlSG9sZC4gUHJpbnQgYSBoZWFkZXIgbWVzc2FnZS5cbiAgICBwcmludChgIOKMmyBQdXNoaW5nIERvY2tlciBpbWFnZSBmb3IgJHtjb250ZXh0UGF0aH07IHRoaXMgbWF5IHRha2UgYSB3aGlsZS5gKTtcbiAgICBhd2FpdCBzaGVsbChbJ2RvY2tlcicsICdwdXNoJywgbGF0ZXN0XSk7XG4gICAgZGVidWcoYCDwn5GRICBEb2NrZXIgaW1hZ2UgZm9yICR7Y29udGV4dFBhdGh9IHB1c2hlZC5gKTtcblxuICAgIC8vIEdldCB0aGUgKHNpbmdsZSkgcmVwby1kaWdlc3QgZm9yIGxhdGVzdCwgd2hpY2gnbGwgYmUgPGVjci5yZXBvc2l0b3J5VXJsPkBzaGEyNTY6PHJlcG9JbWFnZVNoYTI1Nj5cbiAgICBjb25zdCByZXBvRGlnZXN0cyA9IChhd2FpdCBzaGVsbChbJ2RvY2tlcicsICdpbWFnZScsICdpbnNwZWN0JywgbGF0ZXN0LCAnLS1mb3JtYXQnLCAne3tyYW5nZSAuUmVwb0RpZ2VzdHN9fXt7Ln19fHt7ZW5kfX0nXSkpLnRyaW0oKTtcbiAgICBjb25zdCByZXF1aXJlZFByZWZpeCA9IGAke2Vjci5yZXBvc2l0b3J5VXJpfUBzaGEyNTY6YDtcbiAgICBjb25zdCByZXBvRGlnZXN0ID0gcmVwb0RpZ2VzdHMuc3BsaXQoJ3wnKS5maW5kKGRpZ2VzdCA9PiBkaWdlc3Quc3RhcnRzV2l0aChyZXF1aXJlZFByZWZpeCkpO1xuICAgIGlmICghcmVwb0RpZ2VzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gaWRlbnRpZnkgcmVwb3NpdG9yeSBkaWdlc3QgKG5vbmUgc3RhcnRzIHdpdGggJHtyZXF1aXJlZFByZWZpeH0pIGluOlxcbiR7cmVwb0RpZ2VzdHN9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIHsgUGFyYW1ldGVyS2V5OiBhc3NldC5pbWFnZU5hbWVQYXJhbWV0ZXIsIFBhcmFtZXRlclZhbHVlOiByZXBvRGlnZXN0LnJlcGxhY2UoZWNyLnJlcG9zaXRvcnlVcmksIHJlcG9zaXRvcnlOYW1lKSB9LFxuICAgIF07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZS5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBidWlsZGluZyBEb2NrZXIgaW1hZ2UgYXNzZXQ7IHlvdSBuZWVkIHRvIGhhdmUgRG9ja2VyIGluc3RhbGxlZCBpbiBvcmRlciB0byBiZSBhYmxlIHRvIGJ1aWxkIGltYWdlIGFzc2V0cy4gUGxlYXNlIGluc3RhbGwgRG9ja2VyIGFuZCB0cnkgYWdhaW4uJyk7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn1cblxuLyoqXG4gKiBCdWlsZCBhbmQgdXBsb2FkIGEgRG9ja2VyIGltYWdlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVwYXJlQ29udGFpbmVyQXNzZXROZXcoYXNzZW1ibHlEaXI6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXQ6IENvbnRhaW5lckltYWdlQXNzZXRNZXRhZGF0YUVudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sa2l0SW5mbzogVG9vbGtpdEluZm8pIHtcblxuICBpZiAoYXNzZXQuaW1hZ2VOYW1lUGFyYW1ldGVyIHx8ICFhc3NldC5yZXBvc2l0b3J5TmFtZSB8fCAhYXNzZXQuaW1hZ2VUYWcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZG9ja2VyIGltYWdlIGFzc2V0IGNvbmZpZ3VyYXRpb24uIFwicmVwb3NpdG9yeU5hbWVcIiBhbmQgXCJpbWFnZVRhZ1wiIGFyZSByZXF1aXJlZCBhbmQgXCJpbWFnZU5hbWVQYXJhbWV0ZXJcIiBpcyBub3QgYWxsb3dlZGApO1xuICB9XG5cbiAgY29uc3QgY29udGV4dFBhdGggPSBwYXRoLmlzQWJzb2x1dGUoYXNzZXQucGF0aCkgPyBhc3NldC5wYXRoIDogcGF0aC5qb2luKGFzc2VtYmx5RGlyLCBhc3NldC5wYXRoKTtcblxuICBkZWJ1ZygnIPCfkZEgIFByZXBhcmluZyBEb2NrZXIgaW1hZ2UgYXNzZXQ6JywgY29udGV4dFBhdGgpO1xuICBjb25zdCBlY3IgPSBhd2FpdCB0b29sa2l0SW5mby5wcmVwYXJlRWNyUmVwb3NpdG9yeShhc3NldC5yZXBvc2l0b3J5TmFtZSk7XG5cbiAgLy8gaWYgYm90aCByZXBvIG5hbWUgYW5kIGltYWdlIHRhZyBhcmUgZXhwbGljaXRseSBkZWZpbmVkLCB3ZSBhc3N1bWUgdGhlXG4gIC8vIGltYWdlIGlzIGltbXV0YWJsZSBhbmQgY2FuIHNraXAgYnVpbGQgJiBwdXNoLlxuICBkZWJ1ZyhgJHthc3NldC5yZXBvc2l0b3J5TmFtZX06JHthc3NldC5pbWFnZVRhZ306IGNoZWNraW5nIGlmIGltYWdlIGFscmVhZHkgZXhpc3RzYCk7XG4gIGlmIChhd2FpdCB0b29sa2l0SW5mby5jaGVja0VjckltYWdlKGFzc2V0LnJlcG9zaXRvcnlOYW1lLCBhc3NldC5pbWFnZVRhZykpIHtcbiAgICBwcmludChgJHthc3NldC5yZXBvc2l0b3J5TmFtZX06JHthc3NldC5pbWFnZVRhZ306IGltYWdlIGFscmVhZHkgZXhpc3RzLCBza2lwcGluZyBidWlsZCBhbmQgcHVzaGApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHdlIHVzZSBcImxhdGVzdFwiIGZvciBpbWFnZSB0YWcgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggcHJlLTEuMjEuMCBhcHBzLlxuICBjb25zdCBmdWxsSW1hZ2VOYW1lID0gYCR7ZWNyLnJlcG9zaXRvcnlVcml9OiR7YXNzZXQuaW1hZ2VUYWd9YDtcblxuICAvLyByZW5kZXIgXCJkb2NrZXIgYnVpbGRcIiBjb21tYW5kXG5cbiAgY29uc3QgYnVpbGRDb21tYW5kID0gWyAnZG9ja2VyJywgJ2J1aWxkJyBdO1xuXG4gIGJ1aWxkQ29tbWFuZC5wdXNoKCctLXRhZycsIGZ1bGxJbWFnZU5hbWUpO1xuXG4gIGlmIChhc3NldC50YXJnZXQpIHtcbiAgICBidWlsZENvbW1hbmQucHVzaCgnLS10YXJnZXQnLCBhc3NldC50YXJnZXQpO1xuICB9XG5cbiAgaWYgKGFzc2V0LmZpbGUpIHtcbiAgICAgIC8vIHJlbWVtYmVyIHdlIGFzc3VtZSB0aGUgZmlsZSBpcyByZWxhdGl2ZSAod2UgdmFsaWRhdGUgdGhpcyBpbiB0aGUgYXNzZXQgY29uc3RydWN0b3IpXG4gICAgICBidWlsZENvbW1hbmQucHVzaCgnLS1maWxlJywgcGF0aC5qb2luKGNvbnRleHRQYXRoLCBhc3NldC5maWxlKSk7XG4gIH1cblxuICBmb3IgKGNvbnN0IFsga2V5LCB2YWx1ZSBdIG9mIE9iamVjdC5lbnRyaWVzKGFzc2V0LmJ1aWxkQXJncyB8fCB7fSkpIHtcbiAgICBidWlsZENvbW1hbmQucHVzaChgLS1idWlsZC1hcmdgLCBgJHtrZXl9PSR7dmFsdWV9YCk7XG4gIH1cblxuICBidWlsZENvbW1hbmQucHVzaChjb250ZXh0UGF0aCk7XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBzaGVsbChidWlsZENvbW1hbmQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGV4ZWN1dGUgXCJkb2NrZXJcIiBpbiBvcmRlciB0byBidWlsZCBhIGNvbnRhaW5lciBhc3NldC4gUGxlYXNlIGluc3RhbGwgXCJkb2NrZXJcIiBhbmQgdHJ5IGFnYWluLicpO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG5cbiAgLy8gbG9naW4gdG8gRUNSXG4gIGF3YWl0IGRvY2tlckxvZ2luKHRvb2xraXRJbmZvKTtcblxuICAvLyBUaGVyZSdzIG5vIHdheSB0byBtYWtlIHRoaXMgcXVpZXQsIHNvIHdlIGNhbid0IHVzZSBhIFBsZWFzZUhvbGQuIFByaW50IGEgaGVhZGVyIG1lc3NhZ2UuXG4gIHByaW50KGAg4oybIFB1c2hpbmcgRG9ja2VyIGltYWdlIGZvciAke2NvbnRleHRQYXRofTsgdGhpcyBtYXkgdGFrZSBhIHdoaWxlLmApO1xuICBhd2FpdCBzaGVsbChbJ2RvY2tlcicsICdwdXNoJywgZnVsbEltYWdlTmFtZV0pO1xuICBkZWJ1ZyhgIPCfkZEgIERvY2tlciBpbWFnZSBmb3IgJHtjb250ZXh0UGF0aH0gcHVzaGVkLmApO1xufVxuXG4vKipcbiAqIEdldCBjcmVkZW50aWFscyBmcm9tIEVDUiBhbmQgcnVuIGRvY2tlciBsb2dpblxuICovXG5hc3luYyBmdW5jdGlvbiBkb2NrZXJMb2dpbih0b29sa2l0SW5mbzogVG9vbGtpdEluZm8pIHtcbiAgY29uc3QgY3JlZGVudGlhbHMgPSBhd2FpdCB0b29sa2l0SW5mby5nZXRFY3JDcmVkZW50aWFscygpO1xuICBhd2FpdCBzaGVsbChbJ2RvY2tlcicsICdsb2dpbicsXG4gICctLXVzZXJuYW1lJywgY3JlZGVudGlhbHMudXNlcm5hbWUsXG4gICctLXBhc3N3b3JkJywgY3JlZGVudGlhbHMucGFzc3dvcmQsXG4gIGNyZWRlbnRpYWxzLmVuZHBvaW50XSk7XG59Il19