"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const account_cache_1 = require("../lib/api/util/account-cache");
async function makeCache() {
    const dir = await fs.mkdtemp('/tmp/account-cache-test');
    const file = path.join(dir, 'cache.json');
    return {
        cacheDir: dir,
        cacheFile: file,
        cache: new account_cache_1.AccountAccessKeyCache(file),
    };
}
async function nukeCache(cacheDir) {
    await fs.remove(cacheDir);
}
test('get(k) when cache is empty', async () => {
    const { cacheDir, cacheFile, cache } = await makeCache();
    try {
        expect(await cache.get('foo')).toBeUndefined();
        expect(await fs.pathExists(cacheFile)).toBeFalsy();
    }
    finally {
        await nukeCache(cacheDir);
    }
});
test('put(k,v) and then get(k)', async () => {
    const { cacheDir, cacheFile, cache } = await makeCache();
    try {
        await cache.put('key', 'value');
        await cache.put('boo', 'bar');
        expect(await cache.get('key')).toBe('value');
        // create another cache instance on the same file, should still work
        const cache2 = new account_cache_1.AccountAccessKeyCache(cacheFile);
        expect(await cache2.get('boo')).toBe('bar');
        // whitebox: read the file
        expect(await fs.readJson(cacheFile)).toEqual({
            key: 'value',
            boo: 'bar'
        });
    }
    finally {
        await nukeCache(cacheDir);
    }
});
test('fetch(k, resolver) can be used to "atomically" get + resolve + put', async () => {
    const { cacheDir, cache } = await makeCache();
    try {
        expect(await cache.get('foo')).toBeUndefined();
        expect(await cache.fetch('foo', async () => 'bar')).toBe('bar');
        expect(await cache.get('foo')).toBe('bar');
    }
    finally {
        await nukeCache(cacheDir);
    }
});
test(`cache is nuked if it exceeds ${account_cache_1.AccountAccessKeyCache.MAX_ENTRIES} entries`, async () => {
    // This makes a lot of promises, so it can queue for a while...
    jest.setTimeout(30000);
    const { cacheDir, cacheFile, cache } = await makeCache();
    try {
        for (let i = 0; i < account_cache_1.AccountAccessKeyCache.MAX_ENTRIES; ++i) {
            await cache.put(`key${i}`, `value${i}`);
        }
        // verify all values are on disk
        const otherCache = new account_cache_1.AccountAccessKeyCache(cacheFile);
        for (let i = 0; i < account_cache_1.AccountAccessKeyCache.MAX_ENTRIES; ++i) {
            expect(await otherCache.get(`key${i}`)).toBe(`value${i}`);
        }
        // add another value
        await cache.put('nuke-me', 'genesis');
        // now, we expect only `nuke-me` to exist on disk
        expect(await otherCache.get('nuke-me')).toBe('genesis');
        for (let i = 0; i < account_cache_1.AccountAccessKeyCache.MAX_ENTRIES; ++i) {
            expect(await otherCache.get(`key${i}`)).toBeUndefined();
        }
    }
    finally {
        await nukeCache(cacheDir);
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjb3VudC1jYWNoZS50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYWNjb3VudC1jYWNoZS50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUM3QixpRUFBc0U7QUFFdEUsS0FBSyxVQUFVLFNBQVM7SUFDdEIsTUFBTSxHQUFHLEdBQUcsTUFBTSxFQUFFLENBQUMsT0FBTyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDeEQsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDMUMsT0FBTztRQUNMLFFBQVEsRUFBRSxHQUFHO1FBQ2IsU0FBUyxFQUFFLElBQUk7UUFDZixLQUFLLEVBQUUsSUFBSSxxQ0FBcUIsQ0FBQyxJQUFJLENBQUM7S0FDdkMsQ0FBQztBQUNKLENBQUM7QUFFRCxLQUFLLFVBQVUsU0FBUyxDQUFDLFFBQWdCO0lBQ3ZDLE1BQU0sRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUM1QixDQUFDO0FBRUQsSUFBSSxDQUFDLDRCQUE0QixFQUFFLEtBQUssSUFBSSxFQUFFO0lBQzVDLE1BQU0sRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxHQUFHLE1BQU0sU0FBUyxFQUFFLENBQUM7SUFDekQsSUFBSTtRQUNGLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUMvQyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUyxFQUFFLENBQUM7S0FDcEQ7WUFBUztRQUNSLE1BQU0sU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0tBQzNCO0FBQ0gsQ0FBQyxDQUFDLENBQUM7QUFFSCxJQUFJLENBQUMsMEJBQTBCLEVBQUUsS0FBSyxJQUFJLEVBQUU7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dEMsaURBQWlEO1FBQ2pELE1BQU0sQ0FBQyxNQUFNLFVBQVUsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDeEQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLHFDQUFxQixDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUMsRUFBRTtZQUMxRCxNQUFNLENBQUMsTUFBTSxVQUFVLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLGFBQWEsRUFBRSxDQUFDO1NBQ3pEO0tBQ0Y7WUFBUztRQUNSLE1BQU0sU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0tBQzNCO0FBQ0gsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgQWNjb3VudEFjY2Vzc0tleUNhY2hlIH0gZnJvbSAnLi4vbGliL2FwaS91dGlsL2FjY291bnQtY2FjaGUnO1xuXG5hc3luYyBmdW5jdGlvbiBtYWtlQ2FjaGUoKSB7XG4gIGNvbnN0IGRpciA9IGF3YWl0IGZzLm1rZHRlbXAoJy90bXAvYWNjb3VudC1jYWNoZS10ZXN0Jyk7XG4gIGNvbnN0IGZpbGUgPSBwYXRoLmpvaW4oZGlyLCAnY2FjaGUuanNvbicpO1xuICByZXR1cm4ge1xuICAgIGNhY2hlRGlyOiBkaXIsXG4gICAgY2FjaGVGaWxlOiBmaWxlLFxuICAgIGNhY2hlOiBuZXcgQWNjb3VudEFjY2Vzc0tleUNhY2hlKGZpbGUpLFxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBudWtlQ2FjaGUoY2FjaGVEaXI6IHN0cmluZykge1xuICBhd2FpdCBmcy5yZW1vdmUoY2FjaGVEaXIpO1xufVxuXG50ZXN0KCdnZXQoaykgd2hlbiBjYWNoZSBpcyBlbXB0eScsIGFzeW5jICgpID0+IHtcbiAgY29uc3QgeyBjYWNoZURpciwgY2FjaGVGaWxlLCBjYWNoZSB9ID0gYXdhaXQgbWFrZUNhY2hlKCk7XG4gIHRyeSB7XG4gICAgZXhwZWN0KGF3YWl0IGNhY2hlLmdldCgnZm9vJykpLnRvQmVVbmRlZmluZWQoKTtcbiAgICBleHBlY3QoYXdhaXQgZnMucGF0aEV4aXN0cyhjYWNoZUZpbGUpKS50b0JlRmFsc3koKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBudWtlQ2FjaGUoY2FjaGVEaXIpO1xuICB9XG59KTtcblxudGVzdCgncHV0KGssdikgYW5kIHRoZW4gZ2V0KGspJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCB7IGNhY2hlRGlyLCBjYWNoZUZpbGUsIGNhY2hlIH0gPSBhd2FpdCBtYWtlQ2FjaGUoKTtcblxuICB0cnkge1xuICAgIGF3YWl0IGNhY2hlLnB1dCgna2V5JywgJ3ZhbHVlJyk7XG4gICAgYXdhaXQgY2FjaGUucHV0KCdib28nLCAnYmFyJyk7XG4gICAgZXhwZWN0KGF3YWl0IGNhY2hlLmdldCgna2V5JykpLnRvQmUoJ3ZhbHVlJyk7XG5cbiAgICAvLyBjcmVhdGUgYW5vdGhlciBjYWNoZSBpbnN0YW5jZSBvbiB0aGUgc2FtZSBmaWxlLCBzaG91bGQgc3RpbGwgd29ya1xuICAgIGNvbnN0IGNhY2hlMiA9IG5ldyBBY2NvdW50QWNjZXNzS2V5Q2FjaGUoY2FjaGVGaWxlKTtcbiAgICBleHBlY3QoYXdhaXQgY2FjaGUyLmdldCgnYm9vJykpLnRvQmUoJ2JhcicpO1xuXG4gICAgLy8gd2hpdGVib3g6IHJlYWQgdGhlIGZpbGVcbiAgICBleHBlY3QoYXdhaXQgZnMucmVhZEpzb24oY2FjaGVGaWxlKSkudG9FcXVhbCh7XG4gICAgICBrZXk6ICd2YWx1ZScsXG4gICAgICBib286ICdiYXInXG4gICAgfSk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgbnVrZUNhY2hlKGNhY2hlRGlyKTtcbiAgfVxufSk7XG5cbnRlc3QoJ2ZldGNoKGssIHJlc29sdmVyKSBjYW4gYmUgdXNlZCB0byBcImF0b21pY2FsbHlcIiBnZXQgKyByZXNvbHZlICsgcHV0JywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCB7IGNhY2hlRGlyLCBjYWNoZSB9ID0gYXdhaXQgbWFrZUNhY2hlKCk7XG5cbiAgdHJ5IHtcbiAgICBleHBlY3QoYXdhaXQgY2FjaGUuZ2V0KCdmb28nKSkudG9CZVVuZGVmaW5lZCgpO1xuICAgIGV4cGVjdChhd2FpdCBjYWNoZS5mZXRjaCgnZm9vJywgYXN5bmMgKCkgPT4gJ2JhcicpKS50b0JlKCdiYXInKTtcbiAgICBleHBlY3QoYXdhaXQgY2FjaGUuZ2V0KCdmb28nKSkudG9CZSgnYmFyJyk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgbnVrZUNhY2hlKGNhY2hlRGlyKTtcbiAgfVxufSk7XG5cbnRlc3QoYGNhY2hlIGlzIG51a2VkIGlmIGl0IGV4Y2VlZHMgJHtBY2NvdW50QWNjZXNzS2V5Q2FjaGUuTUFYX0VOVFJJRVN9IGVudHJpZXNgLCBhc3luYyAoKSA9PiB7XG4gIC8vIFRoaXMgbWFrZXMgYSBsb3Qgb2YgcHJvbWlzZXMsIHNvIGl0IGNhbiBxdWV1ZSBmb3IgYSB3aGlsZS4uLlxuICBqZXN0LnNldFRpbWVvdXQoMzBfMDAwKTtcblxuICBjb25zdCB7IGNhY2hlRGlyLCBjYWNoZUZpbGUsIGNhY2hlIH0gPSBhd2FpdCBtYWtlQ2FjaGUoKTtcblxuICB0cnkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQWNjb3VudEFjY2Vzc0tleUNhY2hlLk1BWF9FTlRSSUVTOyArK2kpIHtcbiAgICAgIGF3YWl0IGNhY2hlLnB1dChga2V5JHtpfWAsIGB2YWx1ZSR7aX1gKTtcbiAgICB9XG5cbiAgICAvLyB2ZXJpZnkgYWxsIHZhbHVlcyBhcmUgb24gZGlza1xuICAgIGNvbnN0IG90aGVyQ2FjaGUgPSBuZXcgQWNjb3VudEFjY2Vzc0tleUNhY2hlKGNhY2hlRmlsZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBY2NvdW50QWNjZXNzS2V5Q2FjaGUuTUFYX0VOVFJJRVM7ICsraSkge1xuICAgICAgZXhwZWN0KGF3YWl0IG90aGVyQ2FjaGUuZ2V0KGBrZXkke2l9YCkpLnRvQmUoYHZhbHVlJHtpfWApO1xuICAgIH1cblxuICAgIC8vIGFkZCBhbm90aGVyIHZhbHVlXG4gICAgYXdhaXQgY2FjaGUucHV0KCdudWtlLW1lJywgJ2dlbmVzaXMnKTtcblxuICAgIC8vIG5vdywgd2UgZXhwZWN0IG9ubHkgYG51a2UtbWVgIHRvIGV4aXN0IG9uIGRpc2tcbiAgICBleHBlY3QoYXdhaXQgb3RoZXJDYWNoZS5nZXQoJ251a2UtbWUnKSkudG9CZSgnZ2VuZXNpcycpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQWNjb3VudEFjY2Vzc0tleUNhY2hlLk1BWF9FTlRSSUVTOyArK2kpIHtcbiAgICAgIGV4cGVjdChhd2FpdCBvdGhlckNhY2hlLmdldChga2V5JHtpfWApKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IG51a2VDYWNoZShjYWNoZURpcik7XG4gIH1cbn0pO1xuIl19