"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const contextproviders = require("../../lib/context-providers");
const settings_1 = require("../../lib/settings");
const mockSDK = {
    defaultAccount: () => Promise.resolve('123456789012'),
    defaultRegion: () => Promise.resolve('bermuda-triangle-1337'),
    cloudFormation: () => { throw new Error('Not Mocked'); },
    ec2: () => { throw new Error('Not Mocked'); },
    ecr: () => { throw new Error('Not Mocked'); },
    route53: () => { throw new Error('Not Mocked'); },
    s3: () => { throw new Error('Not Mocked'); },
    ssm: () => { throw new Error('Not Mocked'); },
};
test('errors are reported into the context value', async () => {
    // GIVEN
    contextproviders.registerContextProvider('testprovider', class {
        async getValue(_) {
            throw new Error('Something went wrong');
        }
    });
    const context = new settings_1.Context();
    // WHEN
    await contextproviders.provideContextValues([
        { key: 'asdf', props: {}, provider: 'testprovider' }
    ], context, mockSDK);
    // THEN - error is now in context
    // NOTE: error key is inlined here because it's part of the CX-API
    // compatibility surface.
    expect(context.get('asdf').$providerError).toBe('Something went wrong');
});
test('errors are marked transient', async () => {
    // GIVEN
    contextproviders.registerContextProvider('testprovider', class {
        async getValue(_) {
            throw new Error('Something went wrong');
        }
    });
    const context = new settings_1.Context();
    // WHEN
    await contextproviders.provideContextValues([
        { key: 'asdf', props: {}, provider: 'testprovider' }
    ], context, mockSDK);
    // THEN - error is marked transient
    expect(context.get('asdf')[settings_1.TRANSIENT_CONTEXT_KEY]).toBeTruthy();
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJpYy50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZ2VuZXJpYy50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0EsZ0VBQWdFO0FBQ2hFLGlEQUFvRTtBQUVwRSxNQUFNLE9BQU8sR0FBUztJQUNwQixjQUFjLEVBQUUsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUM7SUFDckQsYUFBYSxFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsdUJBQXVCLENBQUM7SUFDN0QsY0FBYyxFQUFFLEdBQUcsRUFBRSxHQUFHLE1BQU0sSUFBSSxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3hELEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxNQUFNLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3QyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsTUFBTSxJQUFJLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0MsT0FBTyxFQUFFLEdBQUcsRUFBRSxHQUFHLE1BQU0sSUFBSSxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pELEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxNQUFNLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1QyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsTUFBTSxJQUFJLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDOUMsQ0FBQztBQUVGLElBQUksQ0FBQyw0Q0FBNEMsRUFBRSxLQUFLLElBQUksRUFBRTtJQUM1RCxRQUFRO0lBQ1IsZ0JBQWdCLENBQUMsdUJBQXVCLENBQUMsY0FBYyxFQUFFO1FBQ2hELEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBdUI7WUFDM0MsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1FBQzFDLENBQUM7S0FDRixDQUFDLENBQUM7SUFDSCxNQUFNLE9BQU8sR0FBRyxJQUFJLGtCQUFPLEVBQUUsQ0FBQztJQUU5QixPQUFPO0lBQ1AsTUFBTSxnQkFBZ0IsQ0FBQyxvQkFBb0IsQ0FBQztRQUMxQyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFO0tBQ3JELEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRXJCLGlDQUFpQztJQUVqQyxrRUFBa0U7SUFDbEUseUJBQXlCO0lBQ3pCLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0FBQzFFLENBQUMsQ0FBQyxDQUFDO0FBRUgsSUFBSSxDQUFDLDZCQUE2QixFQUFFLEtBQUssSUFBSSxFQUFFO0lBQzdDLFFBQVE7SUFDUixnQkFBZ0IsQ0FBQyx1QkFBdUIsQ0FBQyxjQUFjLEVBQUU7UUFDaEQsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUF1QjtZQUMzQyxNQUFNLElBQUksS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUM7UUFDMUMsQ0FBQztLQUNGLENBQUMsQ0FBQztJQUNILE1BQU0sT0FBTyxHQUFHLElBQUksa0JBQU8sRUFBRSxDQUFDO0lBRTlCLE9BQU87SUFDUCxNQUFNLGdCQUFnQixDQUFDLG9CQUFvQixDQUFDO1FBQzFDLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRSxjQUFjLEVBQUU7S0FDckQsRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFFckIsbUNBQW1DO0lBQ25DLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLGdDQUFxQixDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQztBQUNsRSxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElTREsgfSBmcm9tICcuLi8uLi9saWIvYXBpL3V0aWwvc2RrJztcbmltcG9ydCAqIGFzIGNvbnRleHRwcm92aWRlcnMgZnJvbSAnLi4vLi4vbGliL2NvbnRleHQtcHJvdmlkZXJzJztcbmltcG9ydCB7IENvbnRleHQsIFRSQU5TSUVOVF9DT05URVhUX0tFWSB9IGZyb20gJy4uLy4uL2xpYi9zZXR0aW5ncyc7XG5cbmNvbnN0IG1vY2tTREs6IElTREsgPSB7XG4gIGRlZmF1bHRBY2NvdW50OiAoKSA9PiBQcm9taXNlLnJlc29sdmUoJzEyMzQ1Njc4OTAxMicpLFxuICBkZWZhdWx0UmVnaW9uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoJ2Jlcm11ZGEtdHJpYW5nbGUtMTMzNycpLFxuICBjbG91ZEZvcm1hdGlvbjogKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoJ05vdCBNb2NrZWQnKTsgfSxcbiAgZWMyOiAoKSA9PiB7IHRocm93IG5ldyBFcnJvcignTm90IE1vY2tlZCcpOyB9LFxuICBlY3I6ICgpID0+IHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgTW9ja2VkJyk7IH0sXG4gIHJvdXRlNTM6ICgpID0+IHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgTW9ja2VkJyk7IH0sXG4gIHMzOiAoKSA9PiB7IHRocm93IG5ldyBFcnJvcignTm90IE1vY2tlZCcpOyB9LFxuICBzc206ICgpID0+IHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgTW9ja2VkJyk7IH0sXG59O1xuXG50ZXN0KCdlcnJvcnMgYXJlIHJlcG9ydGVkIGludG8gdGhlIGNvbnRleHQgdmFsdWUnLCBhc3luYyAoKSA9PiB7XG4gIC8vIEdJVkVOXG4gIGNvbnRleHRwcm92aWRlcnMucmVnaXN0ZXJDb250ZXh0UHJvdmlkZXIoJ3Rlc3Rwcm92aWRlcicsIGNsYXNzIHtcbiAgICBwdWJsaWMgYXN5bmMgZ2V0VmFsdWUoXzoge1trZXk6IHN0cmluZ106IGFueX0pOiBQcm9taXNlPGFueT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb21ldGhpbmcgd2VudCB3cm9uZycpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGNvbnRleHQgPSBuZXcgQ29udGV4dCgpO1xuXG4gIC8vIFdIRU5cbiAgYXdhaXQgY29udGV4dHByb3ZpZGVycy5wcm92aWRlQ29udGV4dFZhbHVlcyhbXG4gICAgeyBrZXk6ICdhc2RmJywgcHJvcHM6IHt9LCBwcm92aWRlcjogJ3Rlc3Rwcm92aWRlcicgfVxuICBdLCBjb250ZXh0LCBtb2NrU0RLKTtcblxuICAvLyBUSEVOIC0gZXJyb3IgaXMgbm93IGluIGNvbnRleHRcblxuICAvLyBOT1RFOiBlcnJvciBrZXkgaXMgaW5saW5lZCBoZXJlIGJlY2F1c2UgaXQncyBwYXJ0IG9mIHRoZSBDWC1BUElcbiAgLy8gY29tcGF0aWJpbGl0eSBzdXJmYWNlLlxuICBleHBlY3QoY29udGV4dC5nZXQoJ2FzZGYnKS4kcHJvdmlkZXJFcnJvcikudG9CZSgnU29tZXRoaW5nIHdlbnQgd3JvbmcnKTtcbn0pO1xuXG50ZXN0KCdlcnJvcnMgYXJlIG1hcmtlZCB0cmFuc2llbnQnLCBhc3luYyAoKSA9PiB7XG4gIC8vIEdJVkVOXG4gIGNvbnRleHRwcm92aWRlcnMucmVnaXN0ZXJDb250ZXh0UHJvdmlkZXIoJ3Rlc3Rwcm92aWRlcicsIGNsYXNzIHtcbiAgICBwdWJsaWMgYXN5bmMgZ2V0VmFsdWUoXzoge1trZXk6IHN0cmluZ106IGFueX0pOiBQcm9taXNlPGFueT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb21ldGhpbmcgd2VudCB3cm9uZycpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGNvbnRleHQgPSBuZXcgQ29udGV4dCgpO1xuXG4gIC8vIFdIRU5cbiAgYXdhaXQgY29udGV4dHByb3ZpZGVycy5wcm92aWRlQ29udGV4dFZhbHVlcyhbXG4gICAgeyBrZXk6ICdhc2RmJywgcHJvcHM6IHt9LCBwcm92aWRlcjogJ3Rlc3Rwcm92aWRlcicgfVxuICBdLCBjb250ZXh0LCBtb2NrU0RLKTtcblxuICAvLyBUSEVOIC0gZXJyb3IgaXMgbWFya2VkIHRyYW5zaWVudFxuICBleHBlY3QoY29udGV4dC5nZXQoJ2FzZGYnKVtUUkFOU0lFTlRfQ09OVEVYVF9LRVldKS50b0JlVHJ1dGh5KCk7XG59KTtcbiJdfQ==