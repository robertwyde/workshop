"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sinon = require("sinon");
const lib_1 = require("../lib");
const docker_1 = require("../lib/docker");
const os = require("../lib/os");
const mock_sdk_1 = require("./util/mock-sdk");
test('creates repository with given name', async () => {
    // GIVEN
    let createdName;
    const sdk = new mock_sdk_1.MockSDK();
    sdk.stubEcr({
        describeRepositories() {
            return { repositories: [] };
        },
        createRepository(req) {
            createdName = req.repositoryName;
            // Stop the test so that we don't actually docker build
            throw new Error('STOPTEST');
        },
    });
    const toolkit = new lib_1.ToolkitInfo({
        sdk,
        bucketName: 'BUCKET_NAME',
        bucketEndpoint: 'BUCKET_ENDPOINT',
        environment: { name: 'env', account: '1234', region: 'abc' }
    });
    // WHEN
    const asset = {
        id: 'assetId',
        imageNameParameter: 'MyParameter',
        packaging: 'container-image',
        path: '/foo',
        repositoryName: 'some-name',
        sourceHash: '0123456789abcdef',
    };
    try {
        await docker_1.prepareContainerAsset('.', asset, toolkit, false);
    }
    catch (e) {
        if (!/STOPTEST/.test(e.toString())) {
            throw e;
        }
    }
    // THEN
    expect(createdName).toBe('some-name');
});
test('derives repository name from asset id', async () => {
    // GIVEN
    let createdName;
    const sdk = new mock_sdk_1.MockSDK();
    sdk.stubEcr({
        describeRepositories() {
            return { repositories: [] };
        },
        createRepository(req) {
            createdName = req.repositoryName;
            // Stop the test so that we don't actually docker build
            throw new Error('STOPTEST');
        },
    });
    const toolkit = new lib_1.ToolkitInfo({
        sdk,
        bucketName: 'BUCKET_NAME',
        bucketEndpoint: 'BUCKET_ENDPOINT',
        environment: { name: 'env', account: '1234', region: 'abc' }
    });
    // WHEN
    const asset = {
        id: 'Stack:Construct/ABC123',
        imageNameParameter: 'MyParameter',
        packaging: 'container-image',
        path: '/foo',
        sourceHash: '0123456789abcdef',
    };
    try {
        await docker_1.prepareContainerAsset('.', asset, toolkit, false);
    }
    catch (e) {
        if (!/STOPTEST/.test(e.toString())) {
            throw e;
        }
    }
    // THEN
    expect(createdName).toBe('cdk/stack-construct-abc123');
});
test('configures image scanning', async () => {
    // GIVEN
    let putImageScanningConfigurationParams;
    const sdk = new mock_sdk_1.MockSDK();
    sdk.stubEcr({
        describeRepositories() {
            return { repositories: [] };
        },
        createRepository() {
            return {
                repository: {
                    repositoryUri: 'uri'
                }
            };
        },
        putImageScanningConfiguration(params) {
            putImageScanningConfigurationParams = params;
            // Stop the test so that we don't actually docker build
            throw new Error('STOPTEST');
        }
    });
    const toolkit = new lib_1.ToolkitInfo({
        sdk,
        bucketName: 'BUCKET_NAME',
        bucketEndpoint: 'BUCKET_ENDPOINT',
        environment: { name: 'env', account: '1234', region: 'abc' }
    });
    // WHEN
    const asset = {
        id: 'assetId',
        imageNameParameter: 'MyParameter',
        packaging: 'container-image',
        path: '/foo',
        repositoryName: 'some-name',
        sourceHash: '0123456789abcdef',
    };
    try {
        await docker_1.prepareContainerAsset('.', asset, toolkit, false);
    }
    catch (e) {
        if (!/STOPTEST/.test(e.toString())) {
            throw e;
        }
    }
    expect(putImageScanningConfigurationParams).toEqual({
        repositoryName: 'some-name',
        imageScanningConfiguration: {
            scanOnPush: true
        }
    });
});
test('passes the correct target to docker build', async () => {
    // GIVEN
    const toolkit = new lib_1.ToolkitInfo({
        sdk: new mock_sdk_1.MockSDK(),
        bucketName: 'BUCKET_NAME',
        bucketEndpoint: 'BUCKET_ENDPOINT',
        environment: { name: 'env', account: '1234', region: 'abc' }
    });
    const prepareEcrRepositoryStub = sinon.stub(toolkit, 'prepareEcrRepository').resolves({
        repositoryUri: 'uri',
    });
    const shellStub = sinon.stub(os, 'shell').rejects('STOPTEST');
    // WHEN
    const asset = {
        id: 'assetId',
        imageNameParameter: 'MyParameter',
        packaging: 'container-image',
        path: '/foo',
        sourceHash: '1234567890abcdef',
        repositoryName: 'some-name',
        buildArgs: {
            a: 'b',
            c: 'd'
        },
        target: 'a-target',
    };
    try {
        await docker_1.prepareContainerAsset('.', asset, toolkit, false);
    }
    catch (e) {
        if (!/STOPTEST/.test(e.toString())) {
            throw e;
        }
    }
    // THEN
    const command = ['docker', 'build', '--build-arg', 'a=b', '--build-arg', 'c=d', '--tag', `uri:latest`, '/foo', '--target', 'a-target'];
    expect(shellStub.calledWith(command)).toBeTruthy();
    prepareEcrRepositoryStub.restore();
    shellStub.restore();
});
test('passes the correct args to docker build', async () => {
    // GIVEN
    const toolkit = new lib_1.ToolkitInfo({
        sdk: new mock_sdk_1.MockSDK(),
        bucketName: 'BUCKET_NAME',
        bucketEndpoint: 'BUCKET_ENDPOINT',
        environment: { name: 'env', account: '1234', region: 'abc' }
    });
    const prepareEcrRepositoryStub = sinon.stub(toolkit, 'prepareEcrRepository').resolves({
        repositoryUri: 'uri',
    });
    const shellStub = sinon.stub(os, 'shell').rejects('STOPTEST');
    // WHEN
    const asset = {
        id: 'assetId',
        imageNameParameter: 'MyParameter',
        packaging: 'container-image',
        path: '/foo',
        sourceHash: '1234567890abcdef',
        repositoryName: 'some-name',
        buildArgs: {
            a: 'b',
            c: 'd'
        }
    };
    try {
        await docker_1.prepareContainerAsset('.', asset, toolkit, false);
    }
    catch (e) {
        if (!/STOPTEST/.test(e.toString())) {
            throw e;
        }
    }
    // THEN
    const command = ['docker', 'build', '--build-arg', 'a=b', '--build-arg', 'c=d', '--tag', `uri:latest`, '/foo'];
    expect(shellStub.calledWith(command)).toBeTruthy();
    prepareEcrRepositoryStub.restore();
    shellStub.restore();
});
test('relative path', async () => {
    // GIVEN
    const toolkit = new lib_1.ToolkitInfo({
        sdk: new mock_sdk_1.MockSDK(),
        bucketName: 'BUCKET_NAME',
        bucketEndpoint: 'BUCKET_ENDPOINT',
        environment: { name: 'env', account: '1234', region: 'abc' }
    });
    const prepareEcrRepositoryStub = sinon.stub(toolkit, 'prepareEcrRepository').resolves({
        repositoryUri: 'uri',
    });
    const shellStub = sinon.stub(os, 'shell').rejects('STOPTEST');
    // WHEN
    const asset = {
        id: 'assetId',
        imageNameParameter: 'MyParameter',
        packaging: 'container-image',
        path: 'relative-to-assembly',
        sourceHash: '1234567890abcdef',
        repositoryName: 'some-name',
        buildArgs: {
            a: 'b',
            c: 'd'
        }
    };
    try {
        await docker_1.prepareContainerAsset('/assembly/dir/root', asset, toolkit, false);
    }
    catch (e) {
        if (!/STOPTEST/.test(e.toString())) {
            throw e;
        }
    }
    // THEN
    const command = ['docker', 'build', '--build-arg', 'a=b', '--build-arg', 'c=d', '--tag', `uri:latest`, '/assembly/dir/root/relative-to-assembly'];
    expect(shellStub.calledWith(command)).toBeTruthy();
    prepareEcrRepositoryStub.restore();
    shellStub.restore();
});
test('passes the correct file to docker build', async () => {
    // GIVEN
    const toolkit = new lib_1.ToolkitInfo({
        sdk: new mock_sdk_1.MockSDK(),
        bucketName: 'BUCKET_NAME',
        bucketEndpoint: 'BUCKET_ENDPOINT',
        environment: { name: 'env', account: '1234', region: 'abc' }
    });
    const prepareEcrRepositoryStub = sinon.stub(toolkit, 'prepareEcrRepository').resolves({
        repositoryUri: 'uri',
    });
    const shellStub = sinon.stub(os, 'shell').rejects('STOPTEST');
    // WHEN
    const asset = {
        id: 'assetId',
        imageNameParameter: 'MyParameter',
        packaging: 'container-image',
        path: '/foo',
        sourceHash: '1234567890abcdef',
        repositoryName: 'some-name',
        buildArgs: {
            a: 'b',
            c: 'd'
        },
        target: 'a-target',
        file: 'some-file'
    };
    try {
        await docker_1.prepareContainerAsset('.', asset, toolkit, false);
    }
    catch (e) {
        if (!/STOPTEST/.test(e.toString())) {
            throw e;
        }
    }
    const command = ['docker', 'build', '--build-arg', 'a=b', '--build-arg', 'c=d', '--tag', 'uri:latest', '/foo', '--target', 'a-target', '--file', '/foo/some-file'];
    sinon.assert.calledWith(shellStub, command);
    prepareEcrRepositoryStub.restore();
    shellStub.restore();
});
// since "imageNameParameter" is present, this means we are pre 1.21.0, which
// implies which is before "imageTag" was supported. still, for the sake of
// correctness of the protocol we added support for specifying image tag even if
// it's probably not going to be used.
test('"imageTag" is used instead of "latest"', async () => {
    // GIVEN
    const toolkit = new lib_1.ToolkitInfo({
        sdk: new mock_sdk_1.MockSDK(),
        bucketName: 'BUCKET_NAME',
        bucketEndpoint: 'BUCKET_ENDPOINT',
        environment: { name: 'env', account: '1234', region: 'abc' }
    });
    const prepareEcrRepositoryStub = sinon.stub(toolkit, 'prepareEcrRepository').resolves({
        repositoryUri: 'uri',
    });
    const shellStub = sinon.stub(os, 'shell').rejects('STOPTEST');
    // WHEN
    const asset = {
        id: 'assetId',
        imageNameParameter: 'MyParameter',
        packaging: 'container-image',
        path: '/foo',
        sourceHash: '1234567890abcdef',
        repositoryName: 'some-name',
        imageTag: 'image-tag',
        buildArgs: {
            a: 'b',
            c: 'd'
        },
        target: 'a-target',
        file: 'some-file'
    };
    try {
        await docker_1.prepareContainerAsset('.', asset, toolkit, false);
    }
    catch (e) {
        if (!/STOPTEST/.test(e.toString())) {
            throw e;
        }
    }
    // THEN
    const command = ['docker', 'build', '--build-arg', 'a=b', '--build-arg', 'c=d', '--tag', 'uri:image-tag', '/foo', '--target', 'a-target', '--file', '/foo/some-file'];
    sinon.assert.calledWith(shellStub, command);
    prepareEcrRepositoryStub.restore();
    shellStub.restore();
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9ja2VyLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJkb2NrZXIudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLCtCQUErQjtBQUMvQixnQ0FBcUM7QUFDckMsMENBQXNEO0FBQ3RELGdDQUFnQztBQUNoQyw4Q0FBMEM7QUFFMUMsSUFBSSxDQUFDLG9DQUFvQyxFQUFFLEtBQUssSUFBSSxFQUFFO0lBQ3BELFFBQVE7SUFFUixJQUFJLFdBQVcsQ0FBQztJQUVoQixNQUFNLEdBQUcsR0FBRyxJQUFJLGtCQUFPLEVBQUUsQ0FBQztJQUMxQixHQUFHLENBQUMsT0FBTyxDQUFDO1FBQ1Ysb0JBQW9CO1lBQ2xCLE9BQU8sRUFBRSxZQUFZLEVBQUUsRUFBRSxFQUFFLENBQUM7UUFDOUIsQ0FBQztRQUVELGdCQUFnQixDQUFDLEdBQUc7WUFDbEIsV0FBVyxHQUFHLEdBQUcsQ0FBQyxjQUFjLENBQUM7WUFFakMsdURBQXVEO1lBQ3ZELE1BQU0sSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDOUIsQ0FBQztLQUNGLENBQUMsQ0FBQztJQUVILE1BQU0sT0FBTyxHQUFHLElBQUksaUJBQVcsQ0FBQztRQUM5QixHQUFHO1FBQ0gsVUFBVSxFQUFFLGFBQWE7UUFDekIsY0FBYyxFQUFFLGlCQUFpQjtRQUNqQyxXQUFXLEVBQUUsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRTtLQUM3RCxDQUFDLENBQUM7SUFFSCxPQUFPO0lBQ1AsTUFBTSxLQUFLLEdBQTJDO1FBQ3BELEVBQUUsRUFBRSxTQUFTO1FBQ2Isa0JBQWtCLEVBQUUsYUFBYTtRQUNqQyxTQUFTLEVBQUUsaUJBQWlCO1FBQzVCLElBQUksRUFBRSxNQUFNO1FBQ1osY0FBYyxFQUFFLFdBQVc7UUFDM0IsVUFBVSxFQUFFLGtCQUFrQjtLQUMvQixDQUFDO0lBRUYsSUFBSTtRQUNGLE1BQU0sOEJBQXFC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O0tBQ3pEO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRTtZQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQUU7S0FDakQ7SUFFRCxPQUFPO0lBQ1AsTUFBTSxPQUFPLEdBQUcsQ0FBQyxRQUFRLEVBQUUsT0FBTyxFQUFFLGFBQWEsRUFBRSxLQUFLLEVBQUUsYUFBYSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO0lBQ3RLLEtBQUssQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUU1Qyx3QkFBd0IsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNuQyxTQUFTLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDdEIsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgc2lub24gZnJvbSAnc2lub24nO1xuaW1wb3J0IHsgVG9vbGtpdEluZm8gfSBmcm9tICcuLi9saWInO1xuaW1wb3J0IHsgcHJlcGFyZUNvbnRhaW5lckFzc2V0IH0gZnJvbSAnLi4vbGliL2RvY2tlcic7XG5pbXBvcnQgKiBhcyBvcyBmcm9tICcuLi9saWIvb3MnO1xuaW1wb3J0IHsgTW9ja1NESyB9IGZyb20gJy4vdXRpbC9tb2NrLXNkayc7XG5cbnRlc3QoJ2NyZWF0ZXMgcmVwb3NpdG9yeSB3aXRoIGdpdmVuIG5hbWUnLCBhc3luYyAoKSA9PiB7XG4gIC8vIEdJVkVOXG5cbiAgbGV0IGNyZWF0ZWROYW1lO1xuXG4gIGNvbnN0IHNkayA9IG5ldyBNb2NrU0RLKCk7XG4gIHNkay5zdHViRWNyKHtcbiAgICBkZXNjcmliZVJlcG9zaXRvcmllcygpIHtcbiAgICAgIHJldHVybiB7IHJlcG9zaXRvcmllczogW10gfTtcbiAgICB9LFxuXG4gICAgY3JlYXRlUmVwb3NpdG9yeShyZXEpIHtcbiAgICAgIGNyZWF0ZWROYW1lID0gcmVxLnJlcG9zaXRvcnlOYW1lO1xuXG4gICAgICAvLyBTdG9wIHRoZSB0ZXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWN0dWFsbHkgZG9ja2VyIGJ1aWxkXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NUT1BURVNUJyk7XG4gICAgfSxcbiAgfSk7XG5cbiAgY29uc3QgdG9vbGtpdCA9IG5ldyBUb29sa2l0SW5mbyh7XG4gICAgc2RrLFxuICAgIGJ1Y2tldE5hbWU6ICdCVUNLRVRfTkFNRScsXG4gICAgYnVja2V0RW5kcG9pbnQ6ICdCVUNLRVRfRU5EUE9JTlQnLFxuICAgIGVudmlyb25tZW50OiB7IG5hbWU6ICdlbnYnLCBhY2NvdW50OiAnMTIzNCcsIHJlZ2lvbjogJ2FiYycgfVxuICB9KTtcblxuICAvLyBXSEVOXG4gIGNvbnN0IGFzc2V0OiBjeGFwaS5Db250YWluZXJJbWFnZUFzc2V0TWV0YWRhdGFFbnRyeSA9IHtcbiAgICBpZDogJ2Fzc2V0SWQnLFxuICAgIGltYWdlTmFtZVBhcmFtZXRlcjogJ015UGFyYW1ldGVyJyxcbiAgICBwYWNrYWdpbmc6ICdjb250YWluZXItaW1hZ2UnLFxuICAgIHBhdGg6ICcvZm9vJyxcbiAgICByZXBvc2l0b3J5TmFtZTogJ3NvbWUtbmFtZScsXG4gICAgc291cmNlSGFzaDogJzAxMjM0NTY3ODlhYmNkZWYnLFxuICB9O1xuXG4gIHRyeSB7XG4gICAgYXdhaXQgcHJlcGFyZUNvbnRhaW5lckFzc2V0KCcuJywgYXNzZXQsIHRvb2xraXQsIGZhbHNlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICghL1NUT1BURVNULy50ZXN0KGUudG9TdHJpbmcoKSkpIHsgdGhyb3cgZTsgfVxuICB9XG5cbiAgLy8gVEhFTlxuICBleHBlY3QoY3JlYXRlZE5hbWUpLnRvQmUoJ3NvbWUtbmFtZScpO1xufSk7XG5cbnRlc3QoJ2Rlcml2ZXMgcmVwb3NpdG9yeSBuYW1lIGZyb20gYXNzZXQgaWQnLCBhc3luYyAoKSA9PiB7XG4gIC8vIEdJVkVOXG5cbiAgbGV0IGNyZWF0ZWROYW1lO1xuXG4gIGNvbnN0IHNkayA9IG5ldyBNb2NrU0RLKCk7XG4gIHNkay5zdHViRWNyKHtcbiAgICBkZXNjcmliZVJlcG9zaXRvcmllcygpIHtcbiAgICAgIHJldHVybiB7IHJlcG9zaXRvcmllczogW10gfTtcbiAgICB9LFxuXG4gICAgY3JlYXRlUmVwb3NpdG9yeShyZXEpIHtcbiAgICAgIGNyZWF0ZWROYW1lID0gcmVxLnJlcG9zaXRvcnlOYW1lO1xuXG4gICAgICAvLyBTdG9wIHRoZSB0ZXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWN0dWFsbHkgZG9ja2VyIGJ1aWxkXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NUT1BURVNUJyk7XG4gICAgfSxcbiAgfSk7XG5cbiAgY29uc3QgdG9vbGtpdCA9IG5ldyBUb29sa2l0SW5mbyh7XG4gICAgc2RrLFxuICAgIGJ1Y2tldE5hbWU6ICdCVUNLRVRfTkFNRScsXG4gICAgYnVja2V0RW5kcG9pbnQ6ICdCVUNLRVRfRU5EUE9JTlQnLFxuICAgIGVudmlyb25tZW50OiB7IG5hbWU6ICdlbnYnLCBhY2NvdW50OiAnMTIzNCcsIHJlZ2lvbjogJ2FiYycgfVxuICB9KTtcblxuICAvLyBXSEVOXG4gIGNvbnN0IGFzc2V0OiBjeGFwaS5Db250YWluZXJJbWFnZUFzc2V0TWV0YWRhdGFFbnRyeSA9IHtcbiAgICBpZDogJ1N0YWNrOkNvbnN0cnVjdC9BQkMxMjMnLFxuICAgIGltYWdlTmFtZVBhcmFtZXRlcjogJ015UGFyYW1ldGVyJyxcbiAgICBwYWNrYWdpbmc6ICdjb250YWluZXItaW1hZ2UnLFxuICAgIHBhdGg6ICcvZm9vJyxcbiAgICBzb3VyY2VIYXNoOiAnMDEyMzQ1Njc4OWFiY2RlZicsXG4gIH07XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBwcmVwYXJlQ29udGFpbmVyQXNzZXQoJy4nLCBhc3NldCwgdG9vbGtpdCwgZmFsc2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKCEvU1RPUFRFU1QvLnRlc3QoZS50b1N0cmluZygpKSkgeyB0aHJvdyBlOyB9XG4gIH1cblxuICAvLyBUSEVOXG4gIGV4cGVjdChjcmVhdGVkTmFtZSkudG9CZSgnY2RrL3N0YWNrLWNvbnN0cnVjdC1hYmMxMjMnKTtcbn0pO1xuXG50ZXN0KCdjb25maWd1cmVzIGltYWdlIHNjYW5uaW5nJywgYXN5bmMgKCkgPT4ge1xuICAvLyBHSVZFTlxuICBsZXQgcHV0SW1hZ2VTY2FubmluZ0NvbmZpZ3VyYXRpb25QYXJhbXM7XG5cbiAgY29uc3Qgc2RrID0gbmV3IE1vY2tTREsoKTtcbiAgc2RrLnN0dWJFY3Ioe1xuICAgIGRlc2NyaWJlUmVwb3NpdG9yaWVzKCkge1xuICAgICAgcmV0dXJuIHsgcmVwb3NpdG9yaWVzOiBbXSB9O1xuICAgIH0sXG5cbiAgICBjcmVhdGVSZXBvc2l0b3J5KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVwb3NpdG9yeToge1xuICAgICAgICAgIHJlcG9zaXRvcnlVcmk6ICd1cmknXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcblxuICAgIHB1dEltYWdlU2Nhbm5pbmdDb25maWd1cmF0aW9uKHBhcmFtcykge1xuICAgICAgcHV0SW1hZ2VTY2FubmluZ0NvbmZpZ3VyYXRpb25QYXJhbXMgPSBwYXJhbXM7XG5cbiAgICAgIC8vIFN0b3AgdGhlIHRlc3Qgc28gdGhhdCB3ZSBkb24ndCBhY3R1YWxseSBkb2NrZXIgYnVpbGRcbiAgICAgIHRocm93IG5ldyBFcnJvcignU1RPUFRFU1QnKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IHRvb2xraXQgPSBuZXcgVG9vbGtpdEluZm8oe1xuICAgIHNkayxcbiAgICBidWNrZXROYW1lOiAnQlVDS0VUX05BTUUnLFxuICAgIGJ1Y2tldEVuZHBvaW50OiAnQlVDS0VUX0VORFBPSU5UJyxcbiAgICBlbnZpcm9ubWVudDogeyBuYW1lOiAnZW52JywgYWNjb3VudDogJzEyMzQnLCByZWdpb246ICdhYmMnIH1cbiAgfSk7XG5cbiAgLy8gV0hFTlxuICBjb25zdCBhc3NldDogY3hhcGkuQ29udGFpbmVySW1hZ2VBc3NldE1ldGFkYXRhRW50cnkgPSB7XG4gICAgaWQ6ICdhc3NldElkJyxcbiAgICBpbWFnZU5hbWVQYXJhbWV0ZXI6ICdNeVBhcmFtZXRlcicsXG4gICAgcGFja2FnaW5nOiAnY29udGFpbmVyLWltYWdlJyxcbiAgICBwYXRoOiAnL2ZvbycsXG4gICAgcmVwb3NpdG9yeU5hbWU6ICdzb21lLW5hbWUnLFxuICAgIHNvdXJjZUhhc2g6ICcwMTIzNDU2Nzg5YWJjZGVmJyxcbiAgfTtcblxuICB0cnkge1xuICAgIGF3YWl0IHByZXBhcmVDb250YWluZXJBc3NldCgnLicsIGFzc2V0LCB0b29sa2l0LCBmYWxzZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIS9TVE9QVEVTVC8udGVzdChlLnRvU3RyaW5nKCkpKSB7IHRocm93IGU7IH1cbiAgfVxuXG4gIGV4cGVjdChwdXRJbWFnZVNjYW5uaW5nQ29uZmlndXJhdGlvblBhcmFtcykudG9FcXVhbCh7XG4gICAgcmVwb3NpdG9yeU5hbWU6ICdzb21lLW5hbWUnLFxuICAgIGltYWdlU2Nhbm5pbmdDb25maWd1cmF0aW9uOiB7XG4gICAgICBzY2FuT25QdXNoOiB0cnVlXG4gICAgfVxuICB9KTtcbn0pO1xuXG50ZXN0KCdwYXNzZXMgdGhlIGNvcnJlY3QgdGFyZ2V0IHRvIGRvY2tlciBidWlsZCcsIGFzeW5jICgpID0+IHtcbiAgLy8gR0lWRU5cbiAgY29uc3QgdG9vbGtpdCA9IG5ldyBUb29sa2l0SW5mbyh7XG4gICAgc2RrOiBuZXcgTW9ja1NESygpLFxuICAgIGJ1Y2tldE5hbWU6ICdCVUNLRVRfTkFNRScsXG4gICAgYnVja2V0RW5kcG9pbnQ6ICdCVUNLRVRfRU5EUE9JTlQnLFxuICAgIGVudmlyb25tZW50OiB7IG5hbWU6ICdlbnYnLCBhY2NvdW50OiAnMTIzNCcsIHJlZ2lvbjogJ2FiYycgfVxuICB9KTtcblxuICBjb25zdCBwcmVwYXJlRWNyUmVwb3NpdG9yeVN0dWIgPSBzaW5vbi5zdHViKHRvb2xraXQsICdwcmVwYXJlRWNyUmVwb3NpdG9yeScpLnJlc29sdmVzKHtcbiAgICByZXBvc2l0b3J5VXJpOiAndXJpJyxcbiAgfSk7XG5cbiAgY29uc3Qgc2hlbGxTdHViID0gc2lub24uc3R1YihvcywgJ3NoZWxsJykucmVqZWN0cygnU1RPUFRFU1QnKTtcblxuICAvLyBXSEVOXG4gIGNvbnN0IGFzc2V0OiBjeGFwaS5Db250YWluZXJJbWFnZUFzc2V0TWV0YWRhdGFFbnRyeSA9IHtcbiAgICBpZDogJ2Fzc2V0SWQnLFxuICAgIGltYWdlTmFtZVBhcmFtZXRlcjogJ015UGFyYW1ldGVyJyxcbiAgICBwYWNrYWdpbmc6ICdjb250YWluZXItaW1hZ2UnLFxuICAgIHBhdGg6ICcvZm9vJyxcbiAgICBzb3VyY2VIYXNoOiAnMTIzNDU2Nzg5MGFiY2RlZicsXG4gICAgcmVwb3NpdG9yeU5hbWU6ICdzb21lLW5hbWUnLFxuICAgIGJ1aWxkQXJnczoge1xuICAgICAgYTogJ2InLFxuICAgICAgYzogJ2QnXG4gICAgfSxcbiAgICB0YXJnZXQ6ICdhLXRhcmdldCcsXG4gIH07XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBwcmVwYXJlQ29udGFpbmVyQXNzZXQoJy4nLCBhc3NldCwgdG9vbGtpdCwgZmFsc2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKCEvU1RPUFRFU1QvLnRlc3QoZS50b1N0cmluZygpKSkgeyB0aHJvdyBlOyB9XG4gIH1cblxuICAvLyBUSEVOXG4gIGNvbnN0IGNvbW1hbmQgPSBbJ2RvY2tlcicsICdidWlsZCcsICctLWJ1aWxkLWFyZycsICdhPWInLCAnLS1idWlsZC1hcmcnLCAnYz1kJywgJy0tdGFnJywgYHVyaTpsYXRlc3RgLCAnL2ZvbycsICctLXRhcmdldCcsICdhLXRhcmdldCddO1xuICBleHBlY3Qoc2hlbGxTdHViLmNhbGxlZFdpdGgoY29tbWFuZCkpLnRvQmVUcnV0aHkoKTtcblxuICBwcmVwYXJlRWNyUmVwb3NpdG9yeVN0dWIucmVzdG9yZSgpO1xuICBzaGVsbFN0dWIucmVzdG9yZSgpO1xufSk7XG5cbnRlc3QoJ3Bhc3NlcyB0aGUgY29ycmVjdCBhcmdzIHRvIGRvY2tlciBidWlsZCcsIGFzeW5jICgpID0+IHtcbiAgLy8gR0lWRU5cbiAgY29uc3QgdG9vbGtpdCA9IG5ldyBUb29sa2l0SW5mbyh7XG4gICAgc2RrOiBuZXcgTW9ja1NESygpLFxuICAgIGJ1Y2tldE5hbWU6ICdCVUNLRVRfTkFNRScsXG4gICAgYnVja2V0RW5kcG9pbnQ6ICdCVUNLRVRfRU5EUE9JTlQnLFxuICAgIGVudmlyb25tZW50OiB7IG5hbWU6ICdlbnYnLCBhY2NvdW50OiAnMTIzNCcsIHJlZ2lvbjogJ2FiYycgfVxuICB9KTtcblxuICBjb25zdCBwcmVwYXJlRWNyUmVwb3NpdG9yeVN0dWIgPSBzaW5vbi5zdHViKHRvb2xraXQsICdwcmVwYXJlRWNyUmVwb3NpdG9yeScpLnJlc29sdmVzKHtcbiAgICByZXBvc2l0b3J5VXJpOiAndXJpJyxcbiAgfSk7XG5cbiAgY29uc3Qgc2hlbGxTdHViID0gc2lub24uc3R1YihvcywgJ3NoZWxsJykucmVqZWN0cygnU1RPUFRFU1QnKTtcblxuICAvLyBXSEVOXG4gIGNvbnN0IGFzc2V0OiBjeGFwaS5Db250YWluZXJJbWFnZUFzc2V0TWV0YWRhdGFFbnRyeSA9IHtcbiAgICBpZDogJ2Fzc2V0SWQnLFxuICAgIGltYWdlTmFtZVBhcmFtZXRlcjogJ015UGFyYW1ldGVyJyxcbiAgICBwYWNrYWdpbmc6ICdjb250YWluZXItaW1hZ2UnLFxuICAgIHBhdGg6ICcvZm9vJyxcbiAgICBzb3VyY2VIYXNoOiAnMTIzNDU2Nzg5MGFiY2RlZicsXG4gICAgcmVwb3NpdG9yeU5hbWU6ICdzb21lLW5hbWUnLFxuICAgIGJ1aWxkQXJnczoge1xuICAgICAgYTogJ2InLFxuICAgICAgYzogJ2QnXG4gICAgfVxuICB9O1xuXG4gIHRyeSB7XG4gICAgYXdhaXQgcHJlcGFyZUNvbnRhaW5lckFzc2V0KCcuJywgYXNzZXQsIHRvb2xraXQsIGZhbHNlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICghL1NUT1BURVNULy50ZXN0KGUudG9TdHJpbmcoKSkpIHsgdGhyb3cgZTsgfVxuICB9XG5cbiAgLy8gVEhFTlxuICBjb25zdCBjb21tYW5kID0gWydkb2NrZXInLCAnYnVpbGQnLCAnLS1idWlsZC1hcmcnLCAnYT1iJywgJy0tYnVpbGQtYXJnJywgJ2M9ZCcsICctLXRhZycsIGB1cmk6bGF0ZXN0YCwgJy9mb28nXTtcbiAgZXhwZWN0KHNoZWxsU3R1Yi5jYWxsZWRXaXRoKGNvbW1hbmQpKS50b0JlVHJ1dGh5KCk7XG5cbiAgcHJlcGFyZUVjclJlcG9zaXRvcnlTdHViLnJlc3RvcmUoKTtcbiAgc2hlbGxTdHViLnJlc3RvcmUoKTtcbn0pO1xuXG50ZXN0KCdyZWxhdGl2ZSBwYXRoJywgYXN5bmMgKCkgPT4ge1xuICAvLyBHSVZFTlxuICBjb25zdCB0b29sa2l0ID0gbmV3IFRvb2xraXRJbmZvKHtcbiAgICBzZGs6IG5ldyBNb2NrU0RLKCksXG4gICAgYnVja2V0TmFtZTogJ0JVQ0tFVF9OQU1FJyxcbiAgICBidWNrZXRFbmRwb2ludDogJ0JVQ0tFVF9FTkRQT0lOVCcsXG4gICAgZW52aXJvbm1lbnQ6IHsgbmFtZTogJ2VudicsIGFjY291bnQ6ICcxMjM0JywgcmVnaW9uOiAnYWJjJyB9XG4gIH0pO1xuXG4gIGNvbnN0IHByZXBhcmVFY3JSZXBvc2l0b3J5U3R1YiA9IHNpbm9uLnN0dWIodG9vbGtpdCwgJ3ByZXBhcmVFY3JSZXBvc2l0b3J5JykucmVzb2x2ZXMoe1xuICAgIHJlcG9zaXRvcnlVcmk6ICd1cmknLFxuICB9KTtcblxuICBjb25zdCBzaGVsbFN0dWIgPSBzaW5vbi5zdHViKG9zLCAnc2hlbGwnKS5yZWplY3RzKCdTVE9QVEVTVCcpO1xuXG4gIC8vIFdIRU5cbiAgY29uc3QgYXNzZXQ6IGN4YXBpLkNvbnRhaW5lckltYWdlQXNzZXRNZXRhZGF0YUVudHJ5ID0ge1xuICAgIGlkOiAnYXNzZXRJZCcsXG4gICAgaW1hZ2VOYW1lUGFyYW1ldGVyOiAnTXlQYXJhbWV0ZXInLFxuICAgIHBhY2thZ2luZzogJ2NvbnRhaW5lci1pbWFnZScsXG4gICAgcGF0aDogJ3JlbGF0aXZlLXRvLWFzc2VtYmx5JyxcbiAgICBzb3VyY2VIYXNoOiAnMTIzNDU2Nzg5MGFiY2RlZicsXG4gICAgcmVwb3NpdG9yeU5hbWU6ICdzb21lLW5hbWUnLFxuICAgIGJ1aWxkQXJnczoge1xuICAgICAgYTogJ2InLFxuICAgICAgYzogJ2QnXG4gICAgfVxuICB9O1xuXG4gIHRyeSB7XG4gICAgYXdhaXQgcHJlcGFyZUNvbnRhaW5lckFzc2V0KCcvYXNzZW1ibHkvZGlyL3Jvb3QnLCBhc3NldCwgdG9vbGtpdCwgZmFsc2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKCEvU1RPUFRFU1QvLnRlc3QoZS50b1N0cmluZygpKSkgeyB0aHJvdyBlOyB9XG4gIH1cblxuICAvLyBUSEVOXG4gIGNvbnN0IGNvbW1hbmQgPSBbJ2RvY2tlcicsICdidWlsZCcsICctLWJ1aWxkLWFyZycsICdhPWInLCAnLS1idWlsZC1hcmcnLCAnYz1kJywgJy0tdGFnJywgYHVyaTpsYXRlc3RgLCAnL2Fzc2VtYmx5L2Rpci9yb290L3JlbGF0aXZlLXRvLWFzc2VtYmx5J107XG4gIGV4cGVjdChzaGVsbFN0dWIuY2FsbGVkV2l0aChjb21tYW5kKSkudG9CZVRydXRoeSgpO1xuXG4gIHByZXBhcmVFY3JSZXBvc2l0b3J5U3R1Yi5yZXN0b3JlKCk7XG4gIHNoZWxsU3R1Yi5yZXN0b3JlKCk7XG59KTtcblxudGVzdCgncGFzc2VzIHRoZSBjb3JyZWN0IGZpbGUgdG8gZG9ja2VyIGJ1aWxkJywgYXN5bmMgKCkgPT4ge1xuICAvLyBHSVZFTlxuICBjb25zdCB0b29sa2l0ID0gbmV3IFRvb2xraXRJbmZvKHtcbiAgICBzZGs6IG5ldyBNb2NrU0RLKCksXG4gICAgYnVja2V0TmFtZTogJ0JVQ0tFVF9OQU1FJyxcbiAgICBidWNrZXRFbmRwb2ludDogJ0JVQ0tFVF9FTkRQT0lOVCcsXG4gICAgZW52aXJvbm1lbnQ6IHsgbmFtZTogJ2VudicsIGFjY291bnQ6ICcxMjM0JywgcmVnaW9uOiAnYWJjJyB9XG4gIH0pO1xuXG4gIGNvbnN0IHByZXBhcmVFY3JSZXBvc2l0b3J5U3R1YiA9IHNpbm9uLnN0dWIodG9vbGtpdCwgJ3ByZXBhcmVFY3JSZXBvc2l0b3J5JykucmVzb2x2ZXMoe1xuICAgIHJlcG9zaXRvcnlVcmk6ICd1cmknLFxuICB9KTtcblxuICBjb25zdCBzaGVsbFN0dWIgPSBzaW5vbi5zdHViKG9zLCAnc2hlbGwnKS5yZWplY3RzKCdTVE9QVEVTVCcpO1xuXG4gIC8vIFdIRU5cbiAgY29uc3QgYXNzZXQ6IGN4YXBpLkNvbnRhaW5lckltYWdlQXNzZXRNZXRhZGF0YUVudHJ5ID0ge1xuICAgIGlkOiAnYXNzZXRJZCcsXG4gICAgaW1hZ2VOYW1lUGFyYW1ldGVyOiAnTXlQYXJhbWV0ZXInLFxuICAgIHBhY2thZ2luZzogJ2NvbnRhaW5lci1pbWFnZScsXG4gICAgcGF0aDogJy9mb28nLFxuICAgIHNvdXJjZUhhc2g6ICcxMjM0NTY3ODkwYWJjZGVmJyxcbiAgICByZXBvc2l0b3J5TmFtZTogJ3NvbWUtbmFtZScsXG4gICAgYnVpbGRBcmdzOiB7XG4gICAgICBhOiAnYicsXG4gICAgICBjOiAnZCdcbiAgICB9LFxuICAgIHRhcmdldDogJ2EtdGFyZ2V0JyxcbiAgICBmaWxlOiAnc29tZS1maWxlJ1xuICB9O1xuXG4gIHRyeSB7XG4gICAgYXdhaXQgcHJlcGFyZUNvbnRhaW5lckFzc2V0KCcuJywgYXNzZXQsIHRvb2xraXQsIGZhbHNlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICghL1NUT1BURVNULy50ZXN0KGUudG9TdHJpbmcoKSkpIHsgdGhyb3cgZTsgfVxuICB9XG5cbiAgY29uc3QgY29tbWFuZCA9IFsnZG9ja2VyJywgJ2J1aWxkJywgJy0tYnVpbGQtYXJnJywgJ2E9YicsICctLWJ1aWxkLWFyZycsICdjPWQnLCAnLS10YWcnLCAndXJpOmxhdGVzdCcsICcvZm9vJywgJy0tdGFyZ2V0JywgJ2EtdGFyZ2V0JywgJy0tZmlsZScsICcvZm9vL3NvbWUtZmlsZSddO1xuICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChzaGVsbFN0dWIsIGNvbW1hbmQpO1xuXG4gIHByZXBhcmVFY3JSZXBvc2l0b3J5U3R1Yi5yZXN0b3JlKCk7XG4gIHNoZWxsU3R1Yi5yZXN0b3JlKCk7XG59KTtcblxuLy8gc2luY2UgXCJpbWFnZU5hbWVQYXJhbWV0ZXJcIiBpcyBwcmVzZW50LCB0aGlzIG1lYW5zIHdlIGFyZSBwcmUgMS4yMS4wLCB3aGljaFxuLy8gaW1wbGllcyB3aGljaCBpcyBiZWZvcmUgXCJpbWFnZVRhZ1wiIHdhcyBzdXBwb3J0ZWQuIHN0aWxsLCBmb3IgdGhlIHNha2Ugb2Zcbi8vIGNvcnJlY3RuZXNzIG9mIHRoZSBwcm90b2NvbCB3ZSBhZGRlZCBzdXBwb3J0IGZvciBzcGVjaWZ5aW5nIGltYWdlIHRhZyBldmVuIGlmXG4vLyBpdCdzIHByb2JhYmx5IG5vdCBnb2luZyB0byBiZSB1c2VkLlxudGVzdCgnXCJpbWFnZVRhZ1wiIGlzIHVzZWQgaW5zdGVhZCBvZiBcImxhdGVzdFwiJywgYXN5bmMgKCkgPT4ge1xuICAvLyBHSVZFTlxuICBjb25zdCB0b29sa2l0ID0gbmV3IFRvb2xraXRJbmZvKHtcbiAgICBzZGs6IG5ldyBNb2NrU0RLKCksXG4gICAgYnVja2V0TmFtZTogJ0JVQ0tFVF9OQU1FJyxcbiAgICBidWNrZXRFbmRwb2ludDogJ0JVQ0tFVF9FTkRQT0lOVCcsXG4gICAgZW52aXJvbm1lbnQ6IHsgbmFtZTogJ2VudicsIGFjY291bnQ6ICcxMjM0JywgcmVnaW9uOiAnYWJjJyB9XG4gIH0pO1xuXG4gIGNvbnN0IHByZXBhcmVFY3JSZXBvc2l0b3J5U3R1YiA9IHNpbm9uLnN0dWIodG9vbGtpdCwgJ3ByZXBhcmVFY3JSZXBvc2l0b3J5JykucmVzb2x2ZXMoe1xuICAgIHJlcG9zaXRvcnlVcmk6ICd1cmknLFxuICB9KTtcblxuICBjb25zdCBzaGVsbFN0dWIgPSBzaW5vbi5zdHViKG9zLCAnc2hlbGwnKS5yZWplY3RzKCdTVE9QVEVTVCcpO1xuXG4gIC8vIFdIRU5cbiAgY29uc3QgYXNzZXQ6IGN4YXBpLkNvbnRhaW5lckltYWdlQXNzZXRNZXRhZGF0YUVudHJ5ID0ge1xuICAgIGlkOiAnYXNzZXRJZCcsXG4gICAgaW1hZ2VOYW1lUGFyYW1ldGVyOiAnTXlQYXJhbWV0ZXInLFxuICAgIHBhY2thZ2luZzogJ2NvbnRhaW5lci1pbWFnZScsXG4gICAgcGF0aDogJy9mb28nLFxuICAgIHNvdXJjZUhhc2g6ICcxMjM0NTY3ODkwYWJjZGVmJyxcbiAgICByZXBvc2l0b3J5TmFtZTogJ3NvbWUtbmFtZScsXG4gICAgaW1hZ2VUYWc6ICdpbWFnZS10YWcnLFxuICAgIGJ1aWxkQXJnczoge1xuICAgICAgYTogJ2InLFxuICAgICAgYzogJ2QnXG4gICAgfSxcbiAgICB0YXJnZXQ6ICdhLXRhcmdldCcsXG4gICAgZmlsZTogJ3NvbWUtZmlsZSdcbiAgfTtcblxuICB0cnkge1xuICAgIGF3YWl0IHByZXBhcmVDb250YWluZXJBc3NldCgnLicsIGFzc2V0LCB0b29sa2l0LCBmYWxzZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIS9TVE9QVEVTVC8udGVzdChlLnRvU3RyaW5nKCkpKSB7IHRocm93IGU7IH1cbiAgfVxuXG4gIC8vIFRIRU5cbiAgY29uc3QgY29tbWFuZCA9IFsnZG9ja2VyJywgJ2J1aWxkJywgJy0tYnVpbGQtYXJnJywgJ2E9YicsICctLWJ1aWxkLWFyZycsICdjPWQnLCAnLS10YWcnLCAndXJpOmltYWdlLXRhZycsICcvZm9vJywgJy0tdGFyZ2V0JywgJ2EtdGFyZ2V0JywgJy0tZmlsZScsICcvZm9vL3NvbWUtZmlsZSddO1xuICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChzaGVsbFN0dWIsIGNvbW1hbmQpO1xuXG4gIHByZXBhcmVFY3JSZXBvc2l0b3J5U3R1Yi5yZXN0b3JlKCk7XG4gIHNoZWxsU3R1Yi5yZXN0b3JlKCk7XG59KTtcbiJdfQ==